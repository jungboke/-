1
```
#include <string>
#include <vector>

using namespace std;
int M,N;
void rotate(vector<vector<int>>& key){
    vector<vector<int>> temp(M,vector<int>(M));

    for(int i=0;i<M;i++)
        for(int j=0;j<M;j++)
            temp[i][j] = key[j][M-i-1];

    for(int i=0;i<M;i++)
        for(int j=0;j<M;j++)
            key[i][j] = temp[i][j];
}
bool solution(vector<vector<int>> key, vector<vector<int>> lock) {
    bool answer = false;
    vector<pair<int,int>> l_zero;
    vector<pair<int,int>> l_one;
    M = key.size();
    N = lock.size();
    int start_x = N;
    int start_y = N;
    for(int i=0;i<N;i++)
    {
        for(int j=0;j<N;j++)
        {
            if(lock[i][j] == 0) l_zero.push_back(make_pair(i,j));
            if(lock[i][j] == 1) l_one.push_back(make_pair(i,j));
        }
    }
    int t = 4;
    while(t--)
    {
    vector<pair<int,int>> zero;
    rotate(key);
    for(int i=0;i<key.size();i++)
    {
        for(int j=0;j<key[0].size();j++)
        {
            if(key[i][j] == 1) zero.push_back(make_pair(i,j));
        }
    }
    for(int i=0;i<60-M+1;i++)
    {
        for(int j=0;j<60-M+1;j++)
        {
            bool flag = true;
            vector<vector<int>> board(60,vector<int>(60,1));
            for(auto pair : zero)
            {
                board[pair.first+i][pair.second+j] = 0;
            }
            for(auto pair : l_one)
            {
                if(board[pair.first+N][pair.second+N] == 0)
                {
                    flag = false;
                    break;
                }
            }
            for(auto pair : l_zero)
            {
                if(board[pair.first+N][pair.second+N] != 0)
                {
                    flag = false;
                    break;
                }
            }
            if(flag == true)
            {
                return true;
            }
        }
    }
    }
    return answer;
}
```
2
```
#include <string>
#include <vector>
using namespace std;
void rotate(vector<vector<int>> &key)
{
    int M = key.size();
    vector<vector<int>> temp(M,vector<int>(M,0));
    for(int i=0;i<key.size();i++)
    {
        for(int j=0;j<key.size();j++)
        {
            temp[i][j] = key[key.size()-j-1][i];
        }
    }
    key = temp;
}
bool solution(vector<vector<int>> key, vector<vector<int>> lock) {
    bool answer = false;
    int M = key.size();
    int N = lock.size();
    vector<pair<int,int>> lb;
    vector<pair<int,int>> lbone;
    for(int i=0;i<lock.size();i++)
    {
        for(int j=0;j<lock[i].size();j++)
        {
            if(lock[i][j] == 0) lb.push_back(make_pair(i,j));
            else lbone.push_back(make_pair(i,j));
        }
    }
    int t=4;
    while(t--)
    {
        rotate(key);
        vector<pair<int,int>> kb;
        for(int i=0;i<key.size();i++)
        {
            for(int j=0;j<key[i].size();j++)
            {
                if(key[i][j] == 1) kb.push_back(make_pair(i,j));
            }
        }
        for(int i=0;i<60-M+1;i++)
        {
            for(int j=0;j<60-M+1;j++)
            {
                vector<vector<int>> board(60,vector<int>(60,0));
                for(int k=0;k<kb.size();k++)
                {
                    board[kb[k].first+i][kb[k].second+j] = 1;
                }
                bool flag = true;
                for(int k=0;k<lbone.size();k++)
                {
                    if(board[lbone[k].first+N][lbone[k].second+N] == 1)
                    {
                        flag = false;
                        break;
                    }
                }
                for(int k=0;k<lb.size();k++)
                {
                    if(board[lb[k].first+N][lb[k].second+N] != 1)
                    {
                        flag = false;
                        break;
                    }
                }
                if(flag==true)
                {
                    answer = true;
                    return answer;
                }
            }
        }
    }
    return answer;
}
```
+ vector에서 clear()쓰면 넣어둔 원소들이 0 이되는게 아니라 다 제거됨.
+ 배열 회전하는 함수(rotate) 익히기, 고난이도 배열구현 문제임.
+ for(int i=0; i<N; i++)
        for(int j=0; j<N; j++)
            temp_arr[i][j] = arr[N - j -1][i];