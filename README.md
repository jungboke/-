# Programmers

1. 범위 확인을 통한 시간 복잡도 예측
2. 문제의 핵심 알고리즘 정의
3. 문제풀때 상단에 문제풀이 순서 적기
4. 과도한 cin,cout 시, 아래 코드 사용
   ```
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
   ```

## 자료구조

두배열 사이의 교집합을 제거하는데는 map을 활용하는게 find로 제거하는거보다 더빠른듯.

map2[x]--; 시 x가 map2에 존재하지않아도 -1로 생성됨.

map1[string]++를 하고 다시 --를 해서 0이되도 map1에 남아있음.

map도 vector형태로 변형시켜 저장가능함. set과 같은 방식 -> vec.assign(map.begin(),map.end())

getline(cin,x,'\n') 형태는 default로 /n만나면 종료되고, cin.getline(x,100,'\n') 형태는 글자수가 99가 넘거나, /n을 만나면 종료됨.

cout.setf(ios::fixed)로 소수점 아래부분만 출력범위 설정.

cout.precision(4)를 연속해서 쓰면 소수점아래 4자리만 출력. 원래는 총합 4자리.

if(cin.eof())로 eof만나면 종료되게 설정.

string은 index가 초과되어도 오류가 발생하지 않았음. 아마 null로 나오는듯? -> substr 시

iterator로 map 접근하는대신 for(auto pair : m) 처럼 접근해보기

## 트리

다음에는 LCA알고리즘 사용해서 풀어보기.

preorder,postorder,tree형성함수(addNode) 구현, vector<vector> answer(2)로는 내부벡터 사용불가.

트리의 경우 단절선과 단절점 파악이 쉽다는 점을 생각해야했음. 제발 어려워보이면 푸는 알고리즘보다 아이디어부터 생각하기.

## 그리디

BFS를 쓰려면 거리이동시 필요값이 1이여야함.

## DP

## 투포인터

배열의 크기때문에 시간제한이 걸릴거같은 문제중, start,end로 범위를 나눌수 있는 문제는 투포인터로 시도해보기, 위 문제는 같은 경우는 배제해야만 풀수 있음.

vector의 set변형 -> set<string> a(vec.begin(),vec.end())

int형들을 다 더해서 long long으로 만들수 없고 따로 long long으로 형변환뒤 덧셈을 해줘야함.

string의 erase는 (a,b) a:시작인덱스 b:지울개수

vector의 erase는 (a,b) a:시작iterator b:마지막iterator

## 구현

달팽이모양 패턴을 간결하게 분석하는게 중요함.

이런종류의 문제는 칸마다 쪼개서 생각해보기.(분할정복) -> 빗물같은 2차원 그래프 문제

vector에서 clear()쓰면 넣어둔 원소들이 0 이되는게 아니라 다 제거됨.

배열 회전하는 함수(rotate) 익히기, 고난이도 배열구현 문제임.

-> for(int i=0; i<N; i++) for(int j=0; j<N; j++) temp_arr[i][j] = arr[N - j -1][i];

블록내리기 알고리즘 유용할듯 -> 프렌즈4블록

결과값의 1234567로 나눈나머지값을 리턴하라는 문제는 계산도중 int형범위를 초과하니 계산내에서도 나누기를 적용하라는 의미. -> 피보나치

굳이 permutation안쓰고 다중for문으로 풀수있으면 안쓰는게 좋음, substr의 두번째인자 안들어가면 마지막까지라는 뜻임.

## 그래프

사이클 만드는지 여부를 확인하는 문제, bool형 dfs, 왔던곳 다시방문할수 있는 dfs -> twodots

그래프에 bfs를 적용하여 거리계산. 최단거리 계산문제는 다 bfs

반환형int 재귀함수 구현, 그래프에서의 사이클 탐색, 다중 시작점에서의 bfs거리 계산,반환형있는 재귀함수인데 최종반환형없게해서 dfs도중 마지막에서 튕겨져나올때 오류발생함.반환형 재귀함수는 최대한 마지막 튕길때 오류발생 고려하기. -> 서울지하철2호선

일반배열은 memset, vector는 fill로 초기화, 모든 그래프가 연결되지 않고 연결요소로 이루어질수도 있음.

check배열을 solution내에서 선언하면 시간초과발생하는데 오류같음.

완전탐색->이분탐색->bfs순으로 풀이법을 유추할수 있어야함. bfs를 쓰는데 집의 범위가 주어져있지 않으므로, check배열을 쓰지 않고 set을 사용함. 또한 dist배열에 거리를 담고 마지막에 다더하는게 아닌 집을 놓는 상황마다 정답에 거리를 추가해야하므로, while(!q.empty())내에서도 q.size()만큼 돌리고 넘어가면 dist에 +1을 해주는 식으로 생각해야함. 뱀과사다리 게임과 해당문제 같은 이분탐색과 비슷한 모형의 문제에서 bfs를 생각하지 못함. -> 샘터

tuple사용을 통한 3차원 구현. + get<0>(personInfo),get<1>(personInfo),get<2>(personInfo) -> tuple 사용문제 만나본적 거의없음.

factorial 구현

```
long long factorial(int num)
{
    if(num<=1) return 1;
    return num*factorial(num-1);
}
```

## 완전탐색

set을 통한 중복성검사, 비트단위 연산할때 무조건 괄호치기

연산자 배열과 숫자 배열의 합을 구하는 최적의 방법. -> 0만들기

swap함수를 이용한 배열인자 바꾸기

시간복잡도 파악을 못해서 시간초과걸림. 2차원 check배열을 활용하여 안되는 조합을 미리 제외함. 조합 내 포함되면 안되는 조합문제는 이렇게 check배열 활용하면 좋을듯함. -> 한윤정2422

순환배열에 % 사용

직사각형도 정사각형과 같이 90도 rotation가능, 단, N에 유의하고, vector<vector<int>>를 복사 할 경우, 크기가 다르면 안됨. resize()를 통해 크기 변환후 복사하기.

dfs문에 이중for문 집어넣고 돌리면 시간복잡도 매우커짐. 그러니 이중for문말고 idx/m,idx%m으로 이중for문 처럼 구현하기. 처음 dfs문이 돌아가는 순간 이중for문이면 처음이 이중for문만큼 시작됨. -> 종이조각14391

string도 array 취급이라 next_permutation 허용됨.

## 시뮬레이션

함수내부에서 배열을 선언할경우 전부 초기화시켜줘야함. 아니면 쓰레기값. 주변8칸할때 dx,dy값 정확하게 입력하기.

비가 전체내린후에 물복사버그를 진행하는것과 비가 내리는 도중 물복사 버그를 진행시키는 것이 다른것처럼 진행순서 잘확인하기 -> 마법사상어와 비바라기

floor()기호 알아둬야함(아래L).

배열 시뮬레이션 중 한쪽으로 계속 도는 cycle 구현해야함. -> 미세먼지 안녕

굳이 이렇게 어렵게 vector를 매번 생성해주지말고 map[100][100]을 생성해놓고 매번 초기화해서 풀면 훨씬 쉬웠을듯. -> 이차원배열과 연산

시뮬레이션 문제는 빨리풀면서 최대한 구현에 실수가 없도록 하는게 중요한듯. 같은 거리의 적이 많을경우, 가장 왼쪽이라는 조건을 실수해서 오래걸림. -> 캐슬디펜스

## 이분탐색

무엇을 이분탐색기준으로 잡을것인가 잘생각하기.

이분탐색은 lowerbound, upperbound개념으로 생각해보기.

이분탐색은 답이 여러개일때, 등호를 초과에 넣느냐, 미만에 넣느냐에 따라 도달하는 위치가 달라짐.
여러 답 중 최대값을 원하면 올라가도록 등호를 넣어줘야 최대값에 도달함.

## 백트래킹

안될거같으면 애초에 for문에서 거르는게 백트래킹이라고 이해.

set에 vector집어넣을때 순서상관있음.

백트래킹 문제는 for문에서 전부 예외처리 되는 경우도 생각해주어야함. 위문제는 모든 계란이 깨져있어 for문이 생략된 경우, dfs(x+1)이 동작하지 않아 멈춰버림. -> 계란으로계란치기16987

## 분할정복

이제 시뮬레이션 같은 문제는 2중벡터문으로 구현하지말고 전역배열로 설정하자. index범위만 좁혀서보면 크기가 작아져도 전역배열로 커버가능함. 문제푸는 아이디어부터 주석으로 적어놓은다음 풀자.

## 누적합

## 문자열

0/1 정의가능한데 0/0정의안됨, int/int는 double형이 되지 않아 강제형변환필요. erase같은거할때 복사배열쓰는지 꼭확인하기, floor(), ceil() 알아두기, find(vector.begin(),vector,end())로 값찾기 가능,vector find와 string find 다름.

kmp알고리즘 적용방식 익히기.(문자열내에 원하는 문자열찾기) failfunc함수의 vector에서 a[i]의 값은 다음에 같아야할 인덱스임. -> 부분문자열16916

시간문제는 왠만하면 분이나 초로 통일시킨후 해결

문자열 분할할때 마지막 index까지 완전히 처리됐는지 확인하기(ex 배열 끝에 공백추가해야 마지막에 temp에 저장된 내용 사용가능함), next_permutation같은거 돌릴때 원본배열말고 복사배열로 사용해야하는지 꼭 확인하기

stringstream(sstream)을 활용한 공백문자 구분, string.c_str()을 활용한 strtok(https://blockdmask.tistory.com/382) -> 오픈채팅방

1/1000한다고 해서 0.001이 나오려면 형변환 추가적으로 해야함.

집합배열에서 중복되지 않는 값 찾기위해 find(vector.begin(),vector.end())사용 -> 튜플

sort는 같은 경우에는 순서 바꿔주는데 stable_sort는 같은 경우에는 냅둠. 그래서 stable 써야함.

algorithm 라이브러리에 vector나 set이 사용할 수 있는 find, count 함수가 있고, set은 STL로써 스스로 set, find 함수를 가지고 있음.

## 최단거리

플로이드 와샬 : https://chanhuiseok.github.io/posts/algo-50/ / 모든 노드들의 서로 간 최단거리를 한번에 구할 수 있음. 다익스트라를 노드의 개수만큼 실행하면 되긴하는데 시간이 오래걸림.

1차원 배열내 최소이동거리 구하기위한 bfs는 이 방식이 유용할듯함. deque나 priority_queue를 사용하여 가중치가 다른 경우 문제를 해결할 수도 있음.

memset은 0,-1말고 다른값으로 초기화불가능함. 방향그래프는 양방향그래프가 아님.

## 위상정렬

선행되어야 하는 작업들이 모두 끝나야(ind==0) 다음 작업을 할수 있고, 선행작업들마다 최소시간이 다름을 확인해야함. -> 작업2056

## 분리집합

연결그래프인지 비연결그래프인지 알수없는 상황에서 주어진 정점들이 연결되어 있나 확인하기 위해서는 분리집합을 만들어서 모든 Find(i)가 같은지 확인하면 됨.

Union에서는 랭크조절을 위한 weighted union, Find에서는 경로압축을 하여 유니온파인드 속도증가시키기. 유니온파인드의 목적은 분리집합(자료구조)을 만드는 것.

분리집합은 트리를 만든다고 생각. 전역변수로 생성된 배열은 default로 0값 가짐.

분리집합을 할때 Union(x,y)나 Union(y,x)는 차이가 없는듯함.

## 최소스패닝트리

문제 조건 내 연결 그래프라는 조건은 모든 정점이 연결되어 있다는 뜻이고, 최소 간선을 통해 모든 정점을 방문하라는 말은 MST라는 뜻. MST의 간선의 개수는 정점수-1 임.

## 기타

소수찾기 : 에라토스테네스의 체 사용법 -> 소수찾기2, 일반 checkPrime -> 소수찾기

예외처리 : #붙은 알파벳들은 map을 통해 다른 문자로 전환 -> 방금그곡

유클리드 호제법 : -> N개의최소공배수

진수 변환 : -> n진수게임(char배열을 통한 진수변환 사용)

queue를 사용하지 않고 vector로도 해결할수 있는문제는 사용안하는게 좋을듯. -> 캐시

vector를 subvec하려면 copy를 쓰는게 좋을듯.

copy(start,end,temp.begin()) -> end보다 한칸적게 카피되고 temp사이즈는 이미 잡혀있어야함.

while(x--) 형식으로 permutation배열 만들때 x가 음수면 무한대로 진행, 문자열vector sort면 알파벳순
