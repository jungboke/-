1
```
// 범위로 인해 커맨드마다 완전탐색 불가
// 마지막 행 삭제되면 커서 위로 올라가고 나머지는 아래로 내려감
// 복구할 행없을때 z안주어짐
// 표를 벡터로 제작하고 현재커서를 k로 지정, 행마다 구분을 위해 자연수를 입력.
// stack을 만들고 삭제된 행들의 이름과 인덱스를 저장해서 입력.
// 삭제된 행이 복구될 때 현재 k보다 위,아래에 있냐에 따라 k의 값이 변화하는 게 핵심인듯.
// vector의 erase,insert는 삭제하고 다시 배열을 땡겨오거나 밀어야되서 시간복잡도 O(n)
// set은 이진트리로 구현되어있어, erase,insert시 시간복잡도 O(log(n))만큼 걸려서 문제에 요구됨.
// set의 prev,now,erase는 반환값을 가짐.
// 이러한 문자열 파싱문제는 숫자가 10이상인 2자리 일수도 있음.
#include <string>
#include <vector>
#include <algorithm>
#include <stack>
#include <unordered_map>
#include <set>
using namespace std;

string solution(int n, int k, vector<string> cmd) {
    string answer = "";
    for(int i=0;i<n;i++)
    {
        answer += 'X';
    }
    set<int> a;
    stack<int> st;
    for(int i=0;i<n;i++)
    {
        a.insert(i);
    }
    int total = a.size();
    auto now = a.find(k);
    for(int i=0;i<cmd.size();i++)
    {
        if(cmd[i][0]=='D')
        {
            string temp = cmd[i].substr(2);
            int num = stoi(temp);
            while(num--) now = next(now);
        }
        else if(cmd[i][0]=='U')
        {
            string temp = cmd[i].substr(2);
            int num = stoi(temp);
            while(num--) now = prev(now);
        }
        else if(cmd[i][0]=='C')
        {
            st.push(*now);
            now = a.erase(now);// set에서 현재 iterator지운뒤 다음 iterator값 반환
            if(now==a.end()) now = prev(now);
        }
        else if(cmd[i][0]=='Z')
        {
            int x = st.top(); // set에 지웠던 값 집어넣어도 now는 바뀌지 않음
            st.pop();
            a.insert(x);
        }
    }
    for(auto k:a)
    {
        answer[k] = 'O';
    }
    return answer;
}
```