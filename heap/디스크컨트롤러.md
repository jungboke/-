1
```
#include <string>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
struct cmp
{
  bool operator()(vector<int> a,vector<int> b)
  {
      return (a[1]>b[1]);
  }
};
int solution(vector<vector<int>> jobs) {
    int answer = 0;
    sort(jobs.begin(),jobs.end());
    priority_queue<vector<int>,vector<vector<int>>,cmp> q;
    int time = 0;
    int index = 0;
    int sum = 0;
    int cnt = jobs.size();
    while(!((cnt==0)&&(q.empty())))
    {
        while(cnt!=0 && jobs[index][0] <= time)
        {
            q.push(jobs[index]);
            index++;
            cnt--;
        }
        if(!q.empty())
        {
            vector<int> temp = q.top();
            q.pop();
            time += temp[1];
            sum += time-temp[0];
        }
        else time++;
    }
    answer = sum / jobs.size();
    return answer;
}
```
2
```
#include <string>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
struct cmp
{
    bool operator()(vector<int> a,vector<int> b)
    {
        return (a[1] > b[1]);
    }
};
int solution(vector<vector<int>> jobs) {
    int answer = 0;
    priority_queue<vector<int>,vector<vector<int>>,cmp> q;
    int size = jobs.size();
    int time = 0;
    while(jobs.size()!=0 || q.size() != 0)
    {
        if(jobs.size()!=0)
        {
            for(int i=0;i<jobs.size();i++)
            {
                if(jobs[i][0] <= time)
                {
                    q.push(jobs[i]);
                    jobs.erase(jobs.begin()+i);
                    i--;
                }
            }
        }
        if(!q.empty())
        {
            vector<int> how = q.top();
            q.pop();
            time += how[1];
            answer += (time-how[0]);
        }
        else time++;
    }
    answer = answer/size;
    return answer;
}
```
+ 우선순위큐 cmp직접 쓰는방법이랑 while(!((cnt==0)&&(q.empty()))) 형태의 조건문 익히기.
+ q.top()은 맨앞이 아니라 맨뒤임.