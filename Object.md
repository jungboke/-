## 오브젝트

### 중요 개념

0. 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것임.
1. 설계를 어렵게 만드는 것은 의존성이며, 불필요한 의존성을 제거함으로써 해당 문제를 해결할 수 있음.
2. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것임.
3. 훌륭한 설계는 적절한 트레이드오프(ex 자율성vs결합도)의 결과물임.
4. 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계원칙임. 이를 인터페이스와 구현의 분리 원칙이라고 함.
5. 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리해야 클라이언트는 클래스를 사용하며 알아야 하는 지식을 줄일 수 있고, 작성자는 파급효과 걱정을 하지 않고, 내부 구현을 마음대로 변경할 수 있음.
6. 객체의 데이터(인스턴스 변수)를 처리하는 메서드는 언제나 해당 객체가 가지고 있는 게 좋음. 이러면 응집도가 증가함.
7. 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이 핵심임. 클라이언트는 메시지 수신 객체가 메시지에 응답할 수 있다는 것만 알면 됨. 메시지에 응답할 수 있다는 것은 인터페이스를 통해 확인하는 것임.
8. 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킴.
9. 코드 수정을 회피하려는 이유는 두려움이며, 두려움은 변경으로 인해 버그가 생길지 모른다는 불확실성에서 기인함. 따라서 우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드임.
10. 대부분의 사람들은 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 고민함. 이것은 객체지향의 본질과는 거리가 멀고, 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있음. 이를 위해 두가지에 집중해야 함.

```
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라.
```

10. 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 함. 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현해야 함.
11. 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게 해야 함.
12. 클래스의 내부와 외부를 구분해야 하는 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문임. 그리고 해당 객체를 사용하는 클라이언트는 상세정보를 알 필요 없어서 좋고, 개발자는 구현부를 유출하지 않아서 구현의 자유를 얻음.
13. 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 점임. 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현해야 함(ex Money vs Long). 그 개념이 비록 하나의 인스턴스 변수만 포함하더라도, 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음임.
14. 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 좋지 않은 선택임. 항상 예외케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택해야 함(ex NoneDiscountPolicy).
15. NoneDiscountPolicy라는 새로운 클래스를 추가하는 것만으로 애플리케이션의 기능이 확장된 것처럼, 추상화를 중심으로 코드의 구조를 설계하면, 유연하고 확장 가능한 설계를 만들 수 있음.
16. 추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는 것을 방지하기 때문임.
17. 유연성이 필요한 곳에 추상화를 사용하라.
18. 코드 재사용을 위해서는 상속보다 합성이 더 좋음. `합성`은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말함.
19. 상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이지만, 두 가지 관점에서 설계에 안좋은 영향을 끼침.

```
1. 상속은 캡슐화를 위반함(부모 클래스의 내부 구조를 잘 알아야 함).
2. 상속은 설계를 유연하지 못하게 만듦(실행 시점에 객체의 종류 변경 불가능함).
```

20. 합성은 위의 두 문제를 모두 해결하는데, 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하므로, 구현을 효과적으로 캡슐화할 수 있음. 또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만듦.
21. 그렇다고 상속을 절대 사용하지 말라는 뜻이 아닌데, 대부분의 설계에서는 상속과 합성을 함께 사용해야 함.
22. 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것임.
23. 객체지향 패러다임의 관점에서 핵심은 역할, 책임, 협력임.
24. 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현(클래스,상속)에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 됨.
25. 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것임.
26. 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력임. 객체의 상태를 결정하는 것은 객체의 행동임.
27. 따라서 협력은 객체를 설계하는 데 필요한 일종의 `문맥`을 제공함.
28. 객체가 협력에서 어떠한 책임(or 역할)을 맡는지 판단하는 게 해당 객체 설계의 첫단계임.
29. 객체의 책임은 객체가 `무엇을 알고 있는가`와 `무엇을 할 수 있는가`로 구성됨. 예를 들어 Screening은 영화를 예매할 수 있어야 하며, 자신이 상영할 영화(의존성 객체)를 알고 있어야 함.
30. 책임과 메시지의 크기는 다른데, 책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로 더 큼. 하나의 객체가 수행할 수 있다고 생각했던 책임이 나중에는 여러 객체들이 협력해야만 하는 커다란 책임으로 자라는 것이 일반적임.
31. 협력이 중요한 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문임. 객체지향 설계에서 가장 중요한 것은 책임이고, 객체에게 얼마나 적절한 책임을 할당했느냐가 설계의 전체적인 품질을 결정함. 객체의 구현 방법은 상대적으로 책임보다는 덜 중요하며, 책임을 결정한 다음에 고민해도 늦지 않음.
32. CRC카드에서 CRC는 후보-책임-협력을 가리키며, 후보는 클래스,객체,컴포넌트,역할 어떤 것이라도 될 수 있음. CRC카드는 역할을 식별하고, 책임을 할당하며, 협력을 명시적으로 표현하는 구체적이면서도 실용적인 설계 기법임. 협력과 책임을 설계할 때, CRC카드를 사용하면 좋을 듯함.
33. 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것임. 이를 책임 할당을 위한 `정보 전문가 패턴`이라고 부름.
34. 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 보는 것임. 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰나감. 즉, 최초의 책임을 시스템(애플리케이션)이 제공하는 기능으로 두는 것임.
35. 협력을 위한 메시지 설계가 우선이고, 해당 메시지를 처리할 객체를 선택하는 것이 그 뒤임.
36. 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어짐. 그리고 이런 메시지가 메시지를 수신할 객체의 책임을 결정함.
37. 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성함. 협력을 설계하면서 객체의 책임을 식별해 나가는 과정에서 최종적으로 얻게 되는 결과물은 시스템을 구성하는 객체들의 인터페이스와 오퍼레이션의 목록임.
38. 어떤 경우에는 응집도와 결합도의 관점에서 정보 전문가가 아닌 다른 객체에게 책임을 할당하는 것이 더 적절한 경우도 있음. 하지만 기본적인 전략은 책임을 수행할 정보 전문가를 찾는 것임. 정보 전문가에게 책임을 할당하는 것만으로도 상태와 행동을 함께 가지는 자율적인 객체를 만들 가능성이 높아지기 때문임.
39. 이처럼 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 `책임 주도 설계`라고 부름.
40. 다음은 책임 주도 설계 방법의 과정을 정리한 것임.

```
1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악함.
2. 시스템 책임을 더 작은 책임으로 분할함.
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당함.
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾음.
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 됨.
```

41. 책임 주도 설계는 자연스럽게 객체의 구현이 아닌 책임에 집중할 수 있도록 해줌.
42. 책임을 할당할 때 고려해야 하는 두 가지 요소로, 하나는 메시지가 객체를 결정해야 한다는 것이고, 다른 하나는 행동이 상태를 결정한다는 것임.
43. 메시지가 객체를 선택하게 해야 하는 두 가지 중요한 이유가 있음.

```
1. 객체가 최소한의 인터페이스를 가질 수 있게 됨.
2. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 됨.
```

44. 객체가 협력에 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동임. 객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것임. 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정하는 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해함. 객체의 내부 구현을 변경하면, 퍼블릭 인터페이스도 함께 변경되게 됨. 이런 식으로 객체의 내부 구현에 초점을 맞춘 설계 방법을 `데이터 주도 설계`라고 부름.
45. 개별 객체의 상태와 행동이 아닌 시스템의 기능을 구현하기 위한 협력에 초점을 맞춰야만 응집도가 높고 결합도가 낮은 객체들을 창조 할 수 있음.
46. 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 `역할`이라고 부름. 실제로 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는 게 좋음.
47. 역할은 단순하게 객체을 추상화하여 같은 책임을 수행하는 여러 객체들을 담을 수 있는 슬롯으로 생각해도 됨.
48. 메시지 발신 -> 역할 찾기 -> 역할수행 객체 선택 으로 진행됨.
49. 역할에 맞는 객체가 하나뿐이라면, 역할=객체 라고 생각해도 됨.
50. 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있음.
51. 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장에 용이한 유연한 설계로 나아가는 첫걸음임.
52. 인터페이스 업캐스팅, 다형성, 동적바인딩, 상속 등과 같은 기술적 메커니즘들이 모여 유연하고 재사용 가능한 협력을 만들 수 있는 기반을 제공함.
53. 명확한 기준을 세우기 어렵고 정보가 부족한 설계 초반에는 어떤 것이 역할이고, 객체인지 결정을 내리기가 어려울 것임. 또한 도메인 모델 안에는 개념과 객체와 역할이 어지럽게 뒤섞여 있으며, 이것은 사람들이 세계를 바라보는 일반적인 관점임. 이에 대해서 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야 하고, 역할과 객체를 명확하게 구분하는 것은 그리 중요하지 않음. 따라서 애매하다면 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할(추상화)를 분리해내는 것이 가장 좋은 방법임.
54. 설계 초반에 다루는 대부분의 대상은 CRC카드를 설명할 때 언급했던 후보로 취급하는 게 합리적임. 후보는 객체, 역할, 클래스가 될 수 있으며 정확하게 무엇인지 설계 초반에는 그다지 중요하지 않고, 이 시점에서 중요한 것은 협력을 위해 어떤 책임이 필요한지를 이해하는 것임.
55. 다양한 객체들이 협력에 참여한다는 것이 확실하면 역할로 시작하고, 정확한 결정을 내리기 어려운 상황이라면 구체적인 객체로 시작하는 게 좋음.
56. 협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용 가능해짐.
57. 객체지향 커뮤니티에서 오랜 기간 동안 좋은 설계의 특징을 판단할 수 있는 기준에 관해 논의했는데 캡슐화, 응집도, 결합도를 주로 사용함.
58. 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공해주기 때문임. 객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있음. 변경될 가능성이 높은 부분은 구현이라고 부르고 상대적으로 안정적인 부분을 인터페이스라고 부름. 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것임.
59. 객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것임.
60. 응집도는 모듈에 포함된 내부 요소(ex 인스턴스 변수, 메서드)들이 연관돼 있는 정도를 나타내고 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가짐. 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있음. 간단히 말해 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고 모듈의 일부만 변경된다면 응집도가 낮은 것임. 또한 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮은 것임.
61. 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도는 낮다고 말함. 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 됨. `단일책임 원칙`은 클래스는 단 한 가지의 변경 이유만을 가져야 한다는 설계 원칙임.
62. 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도임. 변경의 관점에서 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있음.
63. 캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아짐.
64. getter, setter를 함부로 쓰면 안좋은게 퍼블릭 인터페이스에 인스턴스 변수명이 제대로 노출됨.
65. 객체에게 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드임.
66. 다른 객체에게 접근자 메서드를 통해 값을 변경할 기회를 주지 말고, 본인이 직접 바꿀 수 있도록 해야 캡슐화가 이루어짐. 객체는 단순한 데이터 제공자가 아님.
67. 인터페이스(not Interface, 의존성 객체의 메서드 부분)의 파라미터, 반환값, getter등을 통해서 내부 속성을 유추할 수 있고, 속성값 변경이 메서드의 파라미터 수정을 요구, 메서드 사용부분 전부 수정등으로 파급효과가 발생하므로 캡슐화가 부족하다고 판단됨. 또한 메서드 네임명으로 객체의 속성값이 유추될 수도 있음.
68. 캡슐화란 변할 수 있는 어떤 것이라도 감추는 것임. 그것이 속성의 타입이건, 할인 정책의 종류건 상관없이 내부 구현 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것임.
69. 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 함. 객체가 내부에 어떤 상태를 가지고 그 상태를 관리하는가는 부가적인 문제이고, 중요한 것은 객체가 다른 객체와 협력하는 방식임.
70. 책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 어떤 객체에게 어떤 책임을 할당할지를 결정하기 쉽지 않다는 것임. 책임 할당 과정은 일종의 트레이드 오프 활동이므로 동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라짐. 따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 함.
71. 객체에게 어떤 책임을 할당해야 하는가에 대한 실마리는 협력에서 찾을 수 있음. 객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정됨. 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 함.
72. 협력을 시작하는 주체는 메시지 전송자이기 때문에 협력에 적합한 책임이란 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미함. 다시 말해서 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 하는 것임.
73. 협력에 적합한 책임을 수확하기 위해서는 객체를 결정한 후에 메시지를 선택하는 것이 아니라 메시지를 결정한 후에 객체를 선택해야 함. 메시지가 객체를 선택하게 해야 하는 것임.
74. 메시지기반 설계 관점은 클래스기반의 설계 관점보다 훨씬 유연한 애플리케이션을 만들 수 있게 해줌. 클래스기반의 설계 관점이란 클래스를 결정하고 그 클래스의 책임을 찾아 나서는 것을 말함.
75. 메시지를 먼저 결정하기 때문에 메시지 송신자는 메시지 수신자에 대한 어떠한 가정도 할 수 없음. 메시지 전송자의 관점에서 메시지 수신자가 깔끔하게 캡슐화되는 것임.
76. 올바른 객체지향 설계는 클라이언트가 전송할 메시지를 결정한 후에야 비로소 객체의 상태를 저장하는 데 필요한 내부 데이터에 관해 고민하기 시작함.
77. GRASP 패턴은 책임 할당의 어려움을 해결하기 위한 답을 제시해줌. General Responsibility Assignment Software Pattern의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것임.
78. 설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용함. 도메인 안에는 무수히 많은 개념들이 존재하며 이 도메인 개념들을 책임 할당의 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 좀 더 수월해짐. 따라서 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념임. 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요는 없음. 이 단계에서는 책임을 할당받을 객체들의 종류와 관계에 대한 유용한 정보를 제공할 수 있다면 충분함. 중요한 것은 설계를 시작하는 것이지 도메인 개념들을 완벽하게 정리하는 것이 아님. 도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행해야 함.
79. 메시지는 메시지를 수신할 객체가 아니라 메시지를 전송할 객체의 의도를 반영해서 결정해야 함. 따라서 첫 질문은 다음과 같음. `메시지를 전송할 객체는 무엇을 원하는가?`
80. 두번째 질문은 다음과 같음. `메시지를 수신할 적합한 객체는 누구인가?`
81. 객체의 책임과 책임을 수행하는 데 필요한 상태는 동일한 객체 안에 존재해야 함. 따라서 객체에게 책임을 할당하는 첫번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 할당하는 것임. GRASP에서 이를 `정보전문가 패턴`이라고 부름.
82. 책임을 수행하는 객체가 정보를 알고 있다고 해서 그 정보를 저장하고 있을 필요는 없음. 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있음.
83. 설계 초반부에는 도메인 개념에서 정보전문가에 맞는 객체를 찾는 게 좋음.
84. 메시지를 수신할 객체가 스스로 처리할 수 없는 작업이 있다면 메시지로 도움을 요청해야 하고 메시지는 새로운 객체의 책임으로 할당됨. 이 같은 연쇄적인 메시지 전송과 수신을 통해 협력 공동체가 구성되는 것임.
85. 정보전문가 패턴은 객체에게 책임을 할당할 때 가장 기본이 되는 책임할당 원칙임. 이 패턴을 따르는 것만으로도 자율성이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아짐.
86. 설계는 트레이드오프 활동이기 때문에 동일한 기능을 구현할 수 있는 무수히 많은 설계가 존재함. 따라서 올바른 책임할당을 위해 정보전문가 패턴 이외의 다른 책임할당 패턴들을 함께 고려할 필요가 있음. 책임을 할당할 수 있는 다양한 대안들이 존재한다면 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 게 좋음. GRASP에서는 이를 `낮은 결합도 패턴`과 `높은 응집도 패턴`이라고 부름(ex DiscountCondition이 Movie와 협력하는 게 좋을까, 아니면 Screening과 협력하는 게 좋을까).
87. Movie와 DiscountCondition은 이미 결합되어 있기 때문에 Movie를 DiscountCondition과 협력하게 하면 설계 전체적으로 결합도를 추가하지 않고도 협력을 완성할 수 있음(낮은 결합도 패턴).
88. Screening이 DiscountCondition과 협력해야 한다면 Screening은 기존의 예매를 생성하는 책임에 영화 요금 계산과 관련된 책임 일부를 추가적으로 떠맡게 됨. 본인의 원래 책임외에 추가적인 책임이 생겨서 응집도가 떨어짐(높은 응집도 패턴).
89. 이처럼 책임을 할당하고 코드를 작성하는 매순간마다 낮은 결합도 패턴, 높은 응집도 패턴의 관점에서 전체적인 설계 품질을 검토하면 단순하면서도 재사용 가능하고 유연한 설계를 얻을 수 있을 것임.
90. GRASP의 `창조자 패턴`은 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공함.

```
객체 A를 생성해야 할때, 어떤 객체에게 객체 생성 책임을?
1. B가 A객체를 포함하거나 참조함.
2. B가 A객체를 기록함.
3. B가 A객체를 긴밀하게 사용함.
4. B가 A객체를 초기화하는데 필요한 데이터를 가지고 있음.
```

91. 이처럼 창조자 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것임. 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않음.
92. 협력과 책임이 제대로 동작하는지 확인할 수 있는 유일한 방법은 코드를 작성하고 실행해보는 것 뿐임. 올바르게 설계하고 있는지 궁금하면 코드를 작성해야 함.
93. Screening은 영화를 예매할 책임을 맡으며 그결과로 Reservation 인스턴스를 생성할 책임을 수행해야 함. 다시 말해 Screening은 예매에 대한 정보 전문가인 동시에 Reservation의 창조자임. 책임이 결정됐으므로 메시지를 처리할 수 있는 메서드를 구현하고 동시에 책임을 수행하는 데 필요한 인스턴스 변수를 결정해야 함.
94. 변경에 취약한 클래스란 코드를 수정해야 하는 이유를 하나 이상 가지는 클래스임. 예를 들어 코드 변경의 이유가 순번로직 변경, 기간로직 변경 두가지가 될 수 있음. 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮으며, 이를 해결하기 위해서는 변경의 이유에 따라 클래스를 분리해야 함.
95. 지금 본것처럼, 일반적으로 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋음. 문제는 갓 입문한 개발자들은 클래스 안에서 변경의 이유를 찾는 게 어렵다는 것인데, 변경 이유가 하나 이상인 클래스에 드러나는 패턴을 이해하고 나면 클래스 안에 숨겨진 변경의 이유를 생각보다 쉽게 알아낼 수 있을 것임.

```
1. 인스턴스 변수가 초기화되는 시점을 살펴봐라. 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 채로 냅둠.
2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴봐라. 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮은 것임.
```

96. 클래스를 분리할 때, 다형성을 통해 분리하는 게 좋음. 이때 역할의 개념이 등장하게 됨.
97. 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라는 것이 GRASP의 `다형성 패턴`임. 예를 들어 SequeceCondition, PeriodCondition같이 타입이 나누어지면 다형성 패턴을 적용함.
98. 다형성 패턴은 객체의 타입에 따라 여러 대안들을 수행하는 조건문적인 논리를 사용하지 말라고 경고하며 대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고함.
99. 변경을 캡슐화하도록 책임을 할당하는 것을 GRASP에서 `변경보호 패턴`이라고 함. 다형성 패턴을 쓰면 변경보호 패턴이 자동으로 적용됨. 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당해야 함.
100.  모든 인스턴스 변수는 private로 접근제한자를 설정하는 게 좋을 듯함.
101.  개발자로써 변경에 대비할 수 있는 두가지 방법은 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이고, 다른 하나는 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것임. 상속보다 합성을 사용하는 게 훨씬 변경에 용이함. 합성의 목적은 변경의 용이이며, 변경이 자주 발생하는 곳에 합성을 사용하는 게 좋음.
102.  코드의 구조가 바뀌면 도메인의 구조도 바뀌어야 함. 도메인 모델에 따라 코드의 모습을 정할 수 있으며, 코드의 모습에 따라 모델도 달라져야 함.
103.  여전히 책임을 할당하는 데 어려움을 느끼고 있다면 일단 절차형 코드로 실행되는 프로그램을 빠르게 작성한 후 완성된 코드를 객체지향적인 코드로 변경하는 `리팩토링 기법`을 사용해보는 게 좋음. 이 방법은 실무에서 많은 사람들이 사용하고 있음.
104.  절차형 코드로 작성할 때 발생하는 긴 메서드는 다양한 측면에서 코드의 유지보수에 부정적인 영향을 끼침. 긴 메서드는 응집도가 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어려움. 이러한 메서드를 `몬스터 메서드`라고 부름. 이러한 문제는 이해를 돕기 위해 주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높이는 게 해결책임. 클래스의 응집도와 마찬가지로 메서드의 응집도를 높이는 이유도 변경과 관련이 깊고 작은 메서드들로 조합된 메서드는 마치 주석들을 나열한 것처럼 보이기에 코드를 이해하기도 쉬움.
105.  해당 긴 메서드에서 여러 객체로 책임을 분배할 때 가장 먼저 할일은 메서드를 응집도 있는 수준으로 분해하는 것이고, 이렇게 분리하면 각 메서드를 적절한 클래스로 이동하기에 더 수월해짐.
106.  메서드를 이동할 때, 각 메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동시키면 됨. 어떤 데이터를 사용하는지를 가장 쉽게 알 수 있는 방법은 메서드 안에서 어떤 클래스의 접근자 메서드를 사용하는지 파악하는 것임.
107.  책임주도 설계방법에 익숙하지 않다면 일단 데이터 중심으로 구현한 후 이를 리팩토링하더라도 유사한 결과를 얻을 수 있음. 처음부터 책임주도 설계방법을 따르는 것보다 동작하는 코드를 작성한 후에 리팩토링하는 것은 더 훌륭한 결과물을 낳을 수도 있음.
108.  객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것임. 훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 함. 좀 더 정확하게 말해서 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 함. 여기서 중요한 것은 책임이 객체가 수신할 수 있는 메시지의 기반이 된다는 것임.
109.  애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 알아야 함.
110.  객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성함. 훌륭한 퍼블릭 인터페이스를 얻기 위해서는 책임주도 설계방법을 따르는 것만으로는 부족함. 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 익히고 적용해야 함.
111.  퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법이 있음.

```
1. 디미터 법칙
2. 묻지 말고 시켜라
3. 의도를 드러내는 인터페이스
4. 명령-쿼리 분리
```

112. 디미터 법칙은 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것임. 다시 말해 메시지를 전달하는 객체를 제한함.

```
1. this 객체
2. 메서드의 매개변수
3. this의 속성
4. this의 속성인 컬렉션의 요소
5. 메서드 내에서 생성된 지역 객체
```

113. 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송하는 것을 `기차 충돌`이라고 부름. 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 됨.
114. 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조함. `묻지 말고 시켜라`는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어임.
115. 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고민해야 함.
116. 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향샹시켜야 함. 협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 묻지 말고 시켜라 원칙과 디미터 법칙을 머릿속에서 떠올리는 것은 퍼블릭 인터페이스의 품질을 향상시킬 수 있는 좋은 습관임.
117. 훌륭한 인터페이스를 수확하기 위해서는 객체가 어떻게 작업을 수행하는지를 노출해서는 안됨. 인터페이스는 객체가 어떻게 하는지가 아니라 `무엇을 하는지`를 서술해야 함. 무엇을 하는지를 드러내는 이름은 코드를 읽고 이해하기 쉽게 만들뿐만 아니라 유연한 코드를 낳는 지름길임.
118. 어떻게 수행하는지를 드러내는 이름이란 메서드의 내부 구현을 설명하는 이름으로 결과적으로 협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민할 수밖에 없음. 반면 무엇을 하는지를 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 관해 고민하게 됨. 이것은 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 됨.
119. 또한 메서드가 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층(추상화)으로 묶을 수 있는 가능성이 커짐.
120. 하나의 구현을 가진 메시지의 이름을 일반화하도록 도와주는 간단한 훈련 방법이 있는데 매우 다른 두번째 구현을 상상하는 것임.
121. 디미터 법칙과 묻지 말고 시켜라 스타일을 따르면 자연스럽게 자율적인 객체로 구성된 협력을 얻게 됨.
122. 디미터 법칙과 묻지 말고 시켜라 스타일을 따르는 인터페이스를 얻었다면 인터페이스가 클라이언트의 의도를 올바르게 반영(표현)했는지를 확인해야 함. 이때, 오퍼레이션의 이름은 협력이라는 문맥을 반영해야 하는데 다시 말해 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야 함.
123. 이처럼 디미터 법칙과 묻지 말고 시켜라, 의도를 드러내는 인터페이스는 유연한 인터페이스 설계에 대한 방향성을 제시해줌.
124. 잊지 말아야 하는 사실은 설계가 트레이드오프의 산물이라는 점임. 설계를 적절하게 트레이드오프 할 수 있는 능력이 숙련자와 초보자를 구분하는 가장 중요한 기준이 됨. 초보자는 원칙을 맹목적으로 추종하지만 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시해야 함.
125. 트레이드오프 능력을 기르기 위해 위에서 설명한 원칙들을 적용할 때 고려해볼 만한 몇 가지 이슈가 있음.

```
1. 기차 충돌(도트(.))처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것임.
2. 디미터 법칙과 묻지 말고 시켜라 스타일을 준수하는 것은 항상 긍정적인 결과로만 귀결되는 것이 아님. 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션이 공존하게 됨. 결과적으로 응집도가 낮아지는 결과를 초래함. 단지 인스턴스 변수에 대한 getter만 사용하는 경우, 변수의 변경 이외에 파급효과는 발생하지 않으므로, 캡슐화가 조금 깨지긴 해도 위임 메서드로 발생하는 메시지 수신 객체의 변경요인 증가와 트레이드오프하여 우선권을 챙길 수 있음.
```

126. 가끔씩은 묻는 것 외에는 다른 방법이 존재하지 않는 경우도 존재함. 예를 들어 컬렉션에 포함된 객체들을 처리하는 유일한 방법은 객체에게 물어보는 것임. 이처럼 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달려 있음. 말하고자 하는 바는 객체에게 시키는 것이 항상 가능한 것이 아니고 가끔은 물어야 한다는 점임. 이는 트레이드오프에서 중요하게 생각해봐야 할 점임.
127. 가끔씩 필요에 따라 물어야 한다는 사실에 납득했다면 `명령-쿼리 분리 원칙`을 알아두면 도움이 됨. 명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공함.
128. `프로시저`는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없고, `함수`는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없음.
129. 객체의 상태를 수정하는 오퍼레이션을 `명령`이라고 부르고, 객체와 관련된 정보를 반환하는 오퍼레이션을 `쿼리`라고 부름. 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안됨.
130. 명령-쿼리 분리 원칙에 따라 작성된 객체의 인터페이스를 `명령-쿼리 인터페이스`라고 부름.
131. 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있음. 가장 깔끔한 해결책은 명령과 쿼리를 명확하게 분리하는 것임.
132. 명령-쿼리 인터페이스의 장점은 어떤 메서드가 부수효과를 가지는지를 확인하기 위해 코드를 일일이 다 분석하는 것보다는 메서드가 반환 값을 가지는지 여부만 확인하면 된다는 것임. 그 결과, 코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해질 것임. 즉, 객체의 부수효과를 제어하기가 수월해짐.
133. 쿼리 메서드를 어떤 순서로 몇 번 호출하건 상관없이 항상 결과는 동일할 것임.
134. 디미터 법칙을 준수하고 묻지 말고 시켜라 스타일을 따르면서도 의도를 드러내는 인터페이스를 설계하는 아주 쉬운 방법은 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것임.
135. 명령과 쿼리를 분리하고 계약에 의한 설계 개념을 통해 객체의 협력 방식을 명시적으로 드러낼 수 있는 방법은 객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것임.
136. 우리에게 중요한 것은 협력에 적합한 객체가 아니라 협력에 적합한 메시지임.
137. 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만듦. 따라서 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는 게 중요함. 이런 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술임.
138. interface의 자식 클래스가 interface에 의존하는 이유는 interface에 정의한 오퍼레이션들을 퍼블릭 인터페이스의 일부로 포함시키기 위해서임.
139. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해짐. 이를 `컨텍스트 독립성`이라고 부름. 런타임, 컴파일타임 의존성을 따로 두는 행위 자체가 컨텍스트 독립성을 증가시킴.
140. 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 `의존성 해결`이라고 부름. 의존성을 해결하기 위해서는 일반적으로 다음과 같이 세가지 방법을 사용함.

```
1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
2. 객체 생성 후 setter 메서드를 통해 의존성 해결
3. 메서드 실행 시 인자를 이용해 의존성 해결
```

141. setter 메서드를 이용하는 방법의 단점은 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에 객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있다는 점임. 따라서 더 좋은 방법은 생성자 방식과 setter방식을 혼합하는 것임.
142. 메서드 인자를 사용하는 방식은 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요없이 메서드가 실행되는 동안만 일시적으로 의존 관계가 존재해도 무방하거나, 메서드가 실행될 때마다 의존 대상이 매번 달라져야 하는 경우에 유용함. 하지만 클래스의 메서드를 호출하는 대부분의 경우에 매번 동일한 객체를 인자로 전달하고 있다면 생성자를 이용하는 방식이나 setter 메서드를 이용해 의존성을 지속적으로 유지하는 방식으로 변경하는 것이 좋음.
143. 바람직한 의존성은 재사용성과 관련 있음. 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것임. 다시 말해, 컨텍스트에 독립적인 의존성은 바람직한 의존성이고 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성임. 특정한 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용할 수 있는 유일한 방법은 구현을 변경하는 것 뿐임.
144. 결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정됨. 더 많이 알수록 더 많이 결합됨. 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요함. 이 목적을 달성할 수 있는 가장 효과적인 방법은 추상화임.
145. 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법임.
146. 구체 클래스 의존성 -> 추상 클래스 의존성 -> interface 의존성 순으로 결합도가 감소됨.
147. 결합도를 느슨하게 만들기 위해서는 인스턴스 변수의 타입을 추상 클래스나 interface로 선언하는 것만으로는 부족함. 클래스 안에서 구체 클래스에 대한 모든 의존성을 제거해야만 함.
148. 의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 안에서 직접 생성하는 방법 사이의 가장 큰 차이점은 퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는 지 여부임. 생성자,setter,메서드 인자로 설정하는 방법은 의존성이 명시적으로 퍼블릭 인터페이스에 노출됨. 이를 `명시적인 의존성`이라고 부름. 반면 메서드 내부에서 인스턴스를 직접 생성하는 방식은 의존한다는 사실을 감춤. 이를 `숨겨진 의존성`이라고 부름.
149. 숨겨진 의존성은 의존성 제거를 위해 의존성을 찾을 때 어렵게 만듦. 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없음.
150. 의존성은 명시적으로 표현되어야 함. 의존성을 구현 내부에 숨겨두면 안됨. 경계해야 할 것은 의존성 자체가 아니라 의존성을 감추는 것임.
151. new를 사용하면 클래스 사이의 결합도가 극단적으로 높아짐. new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 하고, 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 함. 따라서 new는 결합도를 높이기 때문에 해로움. 해결 방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것임. 외부에서 인스턴스를 전달받는 방법은 앞에서 살펴본 생성자,setter,메서드 인자를 사용함.
152. 사용과 생성의 책임을 분리하고, 의존성을 생성자에 명시적으로 드러내고, 구체 클래스가 아닌 추상 클래스에 의존하게 함으로써 설계를 유연하게 만들 수 있음. 그 출발은 객체를 생성하는 책임을 객체 내부가 아니라 클라이언트로 옮기는 것에서 시작했다는 점을 기억해야 함.
153. 가끔은 클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있음. 주로 협력하는 기본 객체를 설정하고 싶은 경우가 여기에 속함. 대부분의 경우에는 A의 인스턴스와 협력하고 가끔씩만 B의 인스턴스와 협력한다고 가정하면, 이런 상황에서 모든 경우에 인스턴스를 생성하는 책임을 클라이언트로 옮긴다면 클라이언트들 사이에 중복 코드가 늘어나고 사용성도 나빠짐. 이 문제를 해결하는 방법은 기본 객체 A를 생성하는 생성자를 추가하고 이 생성자에서 interface의 인스턴스를 인자로 받는 생성자를 체이닝하는 것임.

```
public Movie(String title, Duration runningTime, Money fee) {
  this(title, runningTime, fee, new AmountDiscountPolicy(...));
}
```

154. 이렇게 해도 결국 내부에서 new를 사용하기 때문에 결합도가 증가함. 하지만 클라이언트에서 발생하는 중복코드와 사용성 저하와 트레이드오프가 이루어지는 것임. 이 방법은 메서드를 오버로딩하는 경우에도 사용할 수 있음. 그럼에도 가급적 구체 클래스에 대한 의존성을 제거할 수 있는 방법을 찾아보는게 좋음. 종종 모든 결합도가 모이는 새로운 클래스를 추가함으로써 사용성과 유연성이라는 두마리 토끼를 잡을 수 있는 경우가 있는데, FACTORY가 바로 그런 경우임.

```
public Money calculateMovieFee(Screening screening) {
  return calculateMovieFee(screening, new AmountDiscountPolicy(...));
}
```

155. 자바JDK에 포함된 표준 클래스는 변경될 확률이 거의 없으므로 의존성이 문제가 되지 않음. 이런 클래스들에 대해서는 구체 클래스에 의존하거나 직접 인스턴스를 생성하더라도 문제가 없음(ex new ArrayList<>()).
156. 비록 클래스를 직접 생성하더라도 가능한 한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리함(ex List).
157. 예외케이스를 처리하기 위해 코드 내부를 직접 수정하는 것은 안좋음. 해결책은 할인 정책이 존재하지 않는다는 사실을 예외케이스로 처리하지 말고 NoneDiscountPolicy 클래스를 추가하는 것처럼 기존에 Movie와 DiscountPolicy가 협력하던 방식을 따르는 것임. 비슷하게, 중복 할인 정책을 할인 정책의 한 가지로 간주함으로써도 해결가능함.
158. 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지를 쉽게 파악할 수 있음. 코드에 드러난 로직을 해석할 필요없이 객체가 어떤 객체와 연결됐는지를 보는 것만으로도 객체의 행동을 쉽게 예상하고 이해할 수 있기 때문임.
159. 훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계임.
160. 변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼는 것임. 추상화가 수정에 대해 닫혀 있을 수 있는 이유는 변경되지 않을 부분을 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이라는 사실을 기억해야 함.
161. 메시지 수신 객체에서 사용할 인스턴스를 만들 책임이 클라이언트에게 새어나가 클라이언트도 특정한 컨텍스트에 묶이기를 바라지 않을 때, FACTORY를 사용함. 객체 생성에 특화된 FACTORY클래스를 구현하여, factory객체를 주입받아 factory객체가 생성해주는 인스턴스를 받아 사용하는 것임. 이렇게 FACTORY를 사용하면 인스턴스를 생성하는 책임 모두를 FACTORY로 이동할 수 있음.
162. 책임 할당의 가장 기본이 되는 원칙은 정보전문가 패턴인데, 이를 위해 도메인 모델 안의 개념 중에서 후보를 찾게 됨. 그러나 종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 발생함. 실제로 동작하는 애플리케이션은 데이터베이스 접근을 위한 객체와 같이 도메인 개념들을 초월하는 기계적인 개념들을 필요로 할 수 있음. 모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제점에 봉착할 가능성이 높아짐. 이 경우 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결해야 함. 이러한 도메인과 무관한 인공적인 객체를 `순수한 가공물`이라고 부름. factory객체가 이에 속함.
163. 어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면, 순수한 가공물을 추가하고 이 객체에게 책임을 할당해야 함.
164. 설계자로서의 우리의 역할은 도메인 추상화를 기반으로 애플리케이션 로직을 설계하는 동시에 품질의 측면에서 균형을 맞추는 데 필요한 객체들을 창조하는 것임. 먼저 도메인의 본질적인 개념을 표현하는 추상화를 이용해 애플리케이션을 구축하기 시작하고, 도메인 개념이 만족스럽지 못하다면 주저하지 말고 인공적인 객체를 창조해야 함.
165. 도메인 객체에 책임을 할당할 경우 높은 응집도, 낮은 결합도 재사용성 등의 목적을 위반한다면, 도메인 개념을 표현하지 않는 인위적으로 만든 클래스에 매우 응집된 책임을 할당해야 함. 이처럼 순수한 가공물 패턴은 정보전문가 패턴에 따라 책임을 할당한 결과가 바람직하지 않을 경우 대안으로 사용됨.
166. 잘 설계된 객체지향 애플리케이션에서는 interface의 소유권을 서버가 아닌 클라이언트에 위치시킴. 전통적인 패러다임에서는 interface가 하위 수준 모듈에 속했다면 객체지향 패러다임에서는 interface가 상위 수준 모듈에 속하는 것임.
167. 설계의 유연함은 단순성과 명확성의 희생 위에서 자라남. 불필요한 유연성은 불필요한 복잡성을 낳으므로, 단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하는 게 좋음. 하지만 복잡성에 대한 걱정보다 유연하고 재사용 가능한 설계의 필요성이 더 크다면 코드의 구조와 실행 구조를 다르게 만드는 게 좋음.
168. 역할과 객체가 일치한다면, 굳이 유연성을 챙길 필요가 없음. 초보자가 자주 저지르는 실수 중 하나는 객체의 역할과 책임이 자리를 잡기 전에 너무 성급하게 객체 생성에 집중하는 것임. 이것은 객체 생성과 관련된 불필요한 세부사항에 객체를 결합시킴. 중요한 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것보다 우선임. 책임의 불균형이 심화되고 있는 상태에서 객체의 생성 책임을 지우는 것은 설계를 하부의 특정한 메커니즘에 종속적으로 만들 확률이 높음.
169. 민첩하게 변경하기 위해서는 중복 코드를 추가하는 대신 제거해야 함. 기회가 생길 때마다 코드를 DRY하게 만들기 위해 노력해야 함.
170. 자식 클래스의 메서드 안에서 super참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합됨. 따라서 super호출을 제거할 수 있는 방법을 찾아 결합도를 제거해야 함.
171. 상속관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 가리켜 `취약한 기반 클래스 문제`라고 부름.
172. 객체지향의 핵심은 객체들의 협력임. 상속으로 단순히 코드를 재사용하기 위해 불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안됨.
173. 상속계층이 코드를 진화시키는 데 걸림돌이 된다면 추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩토링해야 함. 다시 말해 부모 자식 관계의 클래스들을 추상 클래스의 자식클래스로 바꾸는 것임.
174. 또한 추상화를 적용하면서 클래스들의 이름을 의도를 드러내는 이름으로 바꿔줘야 함.
175. 변경에 유연하게 대처할 수 있는 설계가 대부분의 경우에 정답일 가능성이 높음.
176. 코드 재사용을 위해서는 객체 합성이 클래스 상속보다 더 좋은 방법임.
177. 합성을 사용하면 상속이 초래하는 세 가지 문제점을 해결할 수 있음.

```
1. 불필요한 인터페이스 상속 문제 : 자식 클래스에게 부적합한 부모 클래스의 오퍼레이션이 상속됨.
2. 메서드 오버라이딩의 오작용 문제 : 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 때, 해당 오버라이딩 메서드를 사용하는 부모 클래스의 메서드에 영향을 받는 문제가 발생함.
3. 부모 클래스와 자식 클래스의 동시수정 문제 : 부모 클래스를 변경할 때 자식 클래스도 함께 변경해줘야 함.
```

178. 상속을 합성으로 바꾸는 방법은 매우 간단한데 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 됨.
179. 대부분의 경우 구현에 대한 결합보다 인터페이스에 대한 결합이 더 좋음.
180. 

### 개념

1. 글래스는 이론과 실무의 우선순위에서 이론보다 실무가 먼저라고 함. 소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 실무에 초점을 맞추는 것이 효과적임.
2. 추상적인 개념과 이론은 훌륭한 코드를 작성하는 데 필요한 도구일 뿐임.
3. 로버트 마틴이 '클린 소프트웨어'에서 언급한 소프트웨어 모듈이 가져야 하는 세 가지 기능으로 제대로 실행되어야 함, 변경이 용이해야 함, 이해하기 쉬워야 함 을 들었음.
4. 티켓판매소 예시의 문제점은 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점에서 우리의 상식과 다르게 동작하므로 이해가 잘 안되고, 소극장이 관람객과 판매원에 직접 접근한다는 점에서 강한 결합도를 가지게 되어 변경이 어려워진다는 점임.
5. 위의 변경이 어려워지는 부분에서 의존성이 관련된 문제이고, 과한 의존성은 결합도를 높히게 됨. 하지만 이러한 의존성을 완전히 없애는 것이 정답이 아니라, 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것을 목표로 두어야 함.
6. 티켓판매소 예시에서의 노이해, 변경불용이 문제를 해결하는 방법은 간단하게도, 소극장이 관람객과 판매원에 관해 세세한 부분까지 알지 못하도록 정보를 차단하는 것임. 또한 관람객과 판매원이 스스로 일을 할 수 있는 자율성을 부여하면 됨.
7. 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 함. 캡슐화를 통해 객체 내부로의 접근을 제한하면, 객체 사이의 결합도를 낮출 수 있으므로 설계 변경이 좀 더 용이해짐.
8. 특정 클래스를 캡슐화 하기 위해서는 다른 클래스가 해당 클래스에 직접 접근하는 부분을 전부 해당 클래스가 내부적으로 수행하도록 변경함.
9. 객체의 자율성을 높이는 방향으로 설계를 개선하면, 이해하기 쉽고 유연한 설계를 얻을 수 있음.
10. 프로세스(메서드), 데이터(인스턴스 변수)를 별도의 모듈에 위치시키는 방식을 `절차적 프로그래밍`이라고 부름.
11. 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 `객체지향 프로그래밍`이라고 부름.
12. 현실에서는 수동적인 존재라고 하더라도, 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀜. 이를 의인화라고 부름.
13. 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 `도메인`이라고 부름.
14. 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있음.
15. 클래스의 구조는 도메인의 구조와 유사한 형태를 띄어야 함.
16. 설계된 도메인을 바탕으로 클래스 구조를 작성해야 하고, 클래스 명은 도메인 개념의 이름과 유사하게 지어야 함.
17. 객체가 자율적인 존재로 우뚝서기 위해서는 외부의 간섭을 최소화해야 함.
18. 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이고, 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라고 부름.
19. 메시지 수신 객체가 메시지를 처리하는 방법(메서드)을 자율적으로 결정함.
20. 유사한 클래스를 관리하기 위해 상속, 특히 추상클래스와 인터페이스를 사용함.
21. 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 `Template Method`라고 함.
22. 인터페이스의 공유만 필요한 경우 interface를 사용하고, 구현의 공유가 추가적으로 필요한 경우 abstract class를 사용함.
23. 대부분의 사람들은 상속의 목적이 메서드나 인스턴스 변수를 재사용 하는 것이라고 생각하지만, 상속을 통해 부모 클래스의 인터페이스를 물려받아 부모 클래스 대신 사용될 수 있다는 점이 더 중요함.
24. 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 `구현 상속`이라고 하며, 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 `인터페이스 상속` 이라고 함. 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 함.
25. 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 함.
26. 코드 상에서와 달리 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라짐. 이를 `다형성`이라고 함.
27. 다형성은 객체지향 프로그램의 컴파일타임 의존성과 런타임의존성이 다를 수 있다는 사실에 기반으로 함. 객체지향은 동적 바인딩을 사용하므로, 다형성의 활용이 가능한 것임.
28. 메시지와 메서드를 실행 시점에 바인딩 하는 것을 `동적 바인딩`이라고 하고, 컴파일 시점에 바인딩 하는 것을 `정적 바인딩`이라고 함.
29. 추상화를 사용할 경우 두가지 장점을 누릴 수 있음.

```
1. 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있음.
2. 추상화를 이용하면 설계가 좀 더 유연해짐.
```

30. 추상화의 첫번째 장점을 통해, 추상화를 사용해 애플리케이션의 협력흐름을 상위정책으로 기술할 수 있으며, 간략한 기술 덕에 새로운 기능을 쉽게 추가할 수 있음.
31. 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라 함. 객체가 협력에 참여하기 위해 수행하는 로직을 책임이라고 함. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할(추상화)을 구성함.
32. 메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단임.
33. 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상시킬 수 있음. 자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청함. 메시지 수신 객체 역시 메시지를 처리하던 중에 직접 처리할 수 없는 정보나 행동이 필요한 경우 또 다른 객체에게 도움을 요청함. 이처럼 객체들 사이의 협력을 구성하는 `일련의 요청과 응답의 흐름`을 통해 애플리케이션의 기능이 구현됨.
34. 객체지향 설계에서는 상태를 분할의 중심축으로 삼는 방법, 책임을 분할의 중심축으로 삼는 방법 두 가지가 있음. 데이터 중심의 관점은 객체의 상태에 초점을 맞추고, 책임 중심의 관점은 객체의 행동에 초점을 맞춤. 훌륭한 객체지향 설계는 데이터가 아닌 책임에 초점을 맞춰야 함. 객체의 상태는 구현에 속하고 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너짐. 그에 비해, 객체의 책임을 중심축으로 삼으면, 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써, 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지할 수 있음.
35. 책임중심 설계는 `책임이 무엇인가`를 묻는 것으로 시작한다면 데이터중심 설계는 객체가 내부에 저장해야 하는 `데이터가 무엇인가`를 묻는 것으로 시작함. 책임을 명확히하고 분리하는 작업을 안했으니 관련있을 법한 데이터를 다 때려박는 수밖에 없음. 또한 객체가 무엇을 할 것인가 결정하기 전에 객체가 가져야 할 데이터를 설계함.
36. 데이터중심 설계가 가진 대표적인 문제점은 캡슐화 위반, 높은 결합도, 낮은 응집도임.
37. 데이터에 초점을 맞추게 되면 getter,setter처럼 오퍼레이션 명에 데이터 이름이 들어가게 됨. 또한 `누가 이 객체의 ~를 사용할거야`처럼 협력에 관해 고민하지 않아 협력을 파악하지 못하니 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있도록 최대한 많은 무분별한 접근자 메서드가 추가됨.
38. 이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 `추측에 의한 설계 전략`이라고 부름. 따라서 프로그래머는 내부 상태를 드러내는 메서드를 최대한 많이 추가해야 한다는 압박에 시달릴 수 밖에 없으며 결과적으로 대부분의 내부 구현이 퍼블릭 인터페이스에 그대로 노출될 수 밖에 없음. 그 결과, 캡슐화의 원칙을 위반하는 변경에 취약한 설계를 얻게 됨.
39. 이처럼 데이터중심 설계는 객체의 캡슐화를 약화시키기 때문에 클라이언트가 객체의 구현에 강하게 결합됨. 결합도 측면에서 데이터 중심 설계가 가지는 또 다른 단점은 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합될 수 밖에 없음.
40. 데이터중심 설계가 변경에 취약한 이유는 두가지임.

```
1. 데이터중심 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요함.
2. 데이터중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정함.
```

41. 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성됨. 하나는 객체가 수신하는 메시지의 집합이고 다른 하나는 외부의 객체에게 전송하는 메시지의 집합임. 대부분의 사람들은 객체가 수신하는 메시지에 초점을 맞추지만 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직함.
42. 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 함.
43. 메시지는 오퍼레이션명과 인자로 구성되며, 메시지 전송은 여기에 메시지 수신자를 추가한 것임. 또한 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려있음.
44. 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 함. 또한 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부름. 실제 실행되는 코드인 메서드와는 별개임.
45. 오퍼레이션과 파라미터 목록을 합쳐서 시그니처라고 부름.
46. 부수효과를 기반으로 하는 프로그래밍 방식을 `명령형 프로그래밍`이라고 부름. 반면에 `함수형 프로그래밍`은 부수효과가 존재하지 않는 수학적인 함수에 기반함. 하드웨어의 발달로 병렬처리가 중요해진 최근에는 함수형 프로그래밍의 인기가 상승하고 있음.
47. 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 `개방-폐쇄 원칙(OCP)`라고 부름.
48. `의존성 전이`가 의미하는 것은 다른 객체에 의존할 경우, 다른 객체가 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것임. 의존성은 전이가 될 수 있기 때문에 의존성의 종류를 `직접 의존성`과 `간접 의존성`으로 나누기도 함.
49. 의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성임.
50. 의존성과 관련해서 다뤄야 하는 또 다른 주제는 `런타임 의존성`과 `컴파일타임 의존성`의 차이임. 런타임은 간단하게 애플리케이션이 실행되는 시점이지만, 컴파일타임은 약간 미묘함. 일반적으로 컴파일타임이란 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가리키기도 함. 따라서 어딘가에서 컴파일타임이라는 용어를 보게 된다면 그것이 정말 컴파일이 진행되는 시점을 가리키는 것인지 아니면 코드를 작성하는 시점을 가리키는 것인지를 파악하는 게 중요함.
51. 객체지향 애플리케이션에서 런타임 의존성이 다루는 주제는 객체 사이의 의존성인 반면, 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성임. 여기서 중요한 것은 런타임 의존성과 컴파일타임 의존성이 다를 수 있다는 것임. 사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 함.
52. 유연하고 재사용 가능한 설계를 만들기 위해서는 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 함. 추상클래스(interface 포함)를 의존성으로 둬서 가능함.
53. 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어짐.
54. 의존성은 존재한다, 존재하지 않는다로 표현되고 결합도는 강하다, 느슨하다로 표현됨.
55. 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 `의존성 주입`이라고 부름.
56. 의존성 주입에서는 생성자 주입, setter 주입, 메서드 주입처럼 의존성을 해결하는 세가지 방법을 가르키는 별도의 용어를 정의함.
57. 변경이 빈번한 클래스(하위수준)들의 패키지와 변경이 빈번하지 않은 클래스(상위수준)들의 패키지를 분리해야 하는데, 패키지 내의 어떤 클래스가 수정되더라도 패키지 전체가 재배포되어야 하기 때문임. 또한 클라이언트의 재사용에 필요한 것이 의존성 관계에 있는 interface뿐이라 분리시켜야 하기도 함. 이처럼 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 함. 그리고 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 함. 이 기법을 가리켜 `분리된 인터페이스 패턴`이라고 함. 클라이언트와 추상 클래스를 하나의 패키지로 모으는 것은 클라이언트를 특정한 컨텍스트로부터 완벽하게 독립시킴.
58. 중복 코드는 변경을 방해함. 중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것임. 중복 여부를 판단하는 기준은 변경임. 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드들은 중복임. 중복 코드를 결정하는 기준은 코드의 모양이 아님. 프로그래머들은 `DRY 원칙`을 따라야 하는데, Dont Repeat Yourself라는 반복하지 말라는 뜻임.
59. 중복 코드는 항상 함께 수정돼야 하기 때문에 수정할 때 하나라도 빠트린다면 버그로 이어질 것임.
60. 두 클래스 사이의 중복 코드를 제거하기 위해 클래스에 타입 코드를 추가하고 타입 코드 값에 따라 로직을 분기시키는 방법은 if-else문을 사용하기 때문에 내부의 정보를 노출해야 해서 높은 결합도를 갖게 됨.
61. 중복 코드를 제거하기 위해 상속을 사용하면 부모 클래스와 자식 클래스 사이에 강한 결합이 생겨서 코드를 수정하기 어려워짐.
62. 상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 속속들이 알도록 강요함.
63. 상속의 강한 결합도 문제를 해결하는 가장 일반적인 방법은 자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만드는 것임. 그러나 완전히 없앨 수는 없음. 예를 들어 추상화 메서드 이름을 바꾸면 영향이 감.
64. 중복 코드를 제거할 때 가장 먼저 할 일은 중복 코드 안에서 차이점을 별도의 메서드로 추출하고(변하는 것으로부터 변하지 않는 것을 분리하라), 완전히 같은 부분을 추상 부모 클래스로 올리는 것임. 공통 코드를 옮길 때, 인스턴스 변수보다 메서드를 먼저 이동시키는 게 편한데, 메서드를 옮기고 나면 그 메서드에 필요한 메서드나 인스턴스 변수가 무엇인지를 컴파일 에러를 통해 자동으로 알 수 있기 때문임. 메서드가 동일하지 않았던 부분은 시그니처만 동일하므로, 시그니처만 부모 클래스로 이동시키고, 자식 클래스에서 해당 추상 메서드를 오버라이딩 할 수 있도록 해야 함.
65. 자식 클래스들 사이의 공통점을 부모 클래스로 옮김으로써 실제 코드를 기반으로 상속 계층을 구성할 수 있음. 공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경이유를 가지므로, 단일 책임 원칙을 준수하기 때문에 응집도가 높음.
66. 또한 자식 클래스들이 구현해야 하는 추상 메서드가 부모의 추상 메서드에 의존하고 있기 때문에 의존성 역전 원칙도 준수함.
67. 자식 클래스는 자신의 인스턴스를 생성할 때 부모 클래스에 정의된 인스턴스 변수를 초기화해야 하기 때문에 자연스럽게 부모 클래스에 추가된 인스턴스 변수는 자식 클래스의 초기화 로직에 영향을 미치게 됨. 하지만 인스턴스 초기화 로직을 변경하는 것이 두 클래스에 동일한 코드를 중복시키는 것 보다는 현명한 선택임.
68. 이처럼 상속을 통해 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 `차이에 의한 프로그래밍`이라고 부름.
69. 상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만들기 때문에 정말로 필요한 경우에만 상속을 사용해야 함.
70. 상속이 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는데 비해 `합성`은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용함. 상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일타임에 해결되지만 합성에서 두 객체 사이의 의존성은 런타임에 해결됨. 상속관계는 `is-a`관계라고 부르고 합성 관계는 `has-a`관계라고 부름. 상속관계는 클래스 사이의 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계임.
71. 이 차이는 중요한데, 코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만 합성 관계는 실행시점에 동적으로 변경할 수 있기 때문에 상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있음.
72. 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존함. 따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있음.
73. 코드 재사용의 목적으로 상속을 사용하면 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 함. 특히 기능의 조합을 수행하기 위해 A+B=AB 클래스처럼 수많은 조합된 클래스를 만들어야 함. 이를 `조합의 폭발 문제` 라고 부름. 합성을 사용하는 위 문제도 해결됨.
74. 부모와 자식 클래스 사이에 결합도를 느슨하게 하는 방법으로 자식 클래스에서 구현한 부모의 추상 메서드들이 부모 클래스의 메서드에 구현으로써 참여하게 하는 것임. 자식 클래스는 추상 메서드를 오버라이딩하고 자신만의 로직을 구현해서 부모 클래스에서 정의한 플로우에 개입할 수 있게 됨. 자식은 결국 부모의 추상 메서드를 구현할 뿐이므로 결합도가 많이 낮아짐.
75. 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드를 `훅 메서드`라고 함. 추상 클래스에서 이미 구현된 메서드를 말함.
76. 상속 관계는 컴파일타임에 결정되고 고정되며 실행하는 도중에 변경할 수 없기 때문에, 여러 기능을 조합해야 하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가해야 했지만 합성은 런타임타임에 결정되도록 할 수 있기 때문에 조합의 폭발 문제를 해결할 수 있음.
77. 


### 코딩

1. 일반배열을 ArrayList같은 List에 추가하기 위해서는 Arrays.asList()를 통해 List로 변경해준 뒤, addAll()을 사용해야 함.
2. List의 remove()는 제거와 동시에 값을 반환해줌.
