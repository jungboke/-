## 오브젝트

### 목차

1장. 객체, 설계 : 티켓 판매 시스템을 통해 책의 전체적인 주제를 함축해서 전달
2장. 객체지향 프로그래밍 : 영화 예매 시스템의 도메인을 설명하고 객체지향적으로 작성된 코드를 소개
3장. 역할, 책임, 협력 : 영화 예매 시스템을 역할, 책임, 협력의 관점에서 설명하며, 책임 주도 설계 방법 소개
4장. 설계 품질과 트레이드오프 : 절차적 프로그래밍 방식과 비교하며, 품질을 평가하기 위한 캡슐화, 응집도, 결합도 개념을 소개
5장. 책임 할당하기 : GRASP라고 부르는 책임 할당 패턴을 설명
6장. 메시지와 인터페이스 : 훌륭한 퍼블릭 인터페이스를 작성하기 위해 따라야 하는 설계 원칙을 소개
7장. 객체 분해 : 추상화의 한가지 방법인 분해의 역사 소개
8장. 의존성 관리하기 : 의존성의 개념을 자세히 설명하고 결합도를 느슨하게 유지할 수 있는 다양한 설계 방법들을 설명
9장. 유연한 설계 : 8장에서 설명한 기법들을 원칙이라는 관점에서 정리
10장. 상속과 코드 재사용 : 객체지향의 대표적인 재사용 기법인 상속에 관해 설명 및 코드 재사용 목적의 상속을 경고
11장. 합성과 유연한 설계 : 코드를 재사용하기 위해 상속 대신 사용할 수 있는 기법인 합성을 소개
12장. 다형성 : 객체지향의 핵심 메커니즘 중 하나라고 불리는 다형성에 관해 설명
13장. 서브클래싱과 서브타이핑 : 슈퍼타입과 서브타입의 개념을 설명하고 타입 계층을 만족시키기 위한 설계 원칙을 설명
14장. 일관성 있는 협력 : 유사한 요구사항을 구현하기 위한 유사한 협력 패턴 적용의 필요성에 대한 설명
15장. 디자인 패턴과 프레임워크 : 설계를 재사용하는 디자인 패턴과 설계와 코드를 재사용하는 프레임워크에 관해 설명
부록A. 계약에 의한 설계 : 객체들이 협력을 위해 따라야 하는 약속을 계약의 관점에서 설명
부록B. 타입 계층의 구현 : 상속이 아닌 다른 방법으로도 타입 계층을 구현할 수 있다는 사실을 설명
부록C. 동적인 협력, 정적인 코드 : 동적인 협력을 기반으로 정적인 코드를 구성해야 한다는 사실을 설명

### 중요 개념

0. 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것임.
1. 설계를 어렵게 만드는 것은 의존성이며, 불필요한 의존성을 제거함으로써 해당 문제를 해결할 수 있음.
2. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것임.
3. 훌륭한 설계는 적절한 트레이드오프(ex 자율성vs결합도)의 결과물임.
4. 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계원칙임. 이를 인터페이스와 구현의 분리 원칙이라고 함.
5. 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리해야 클라이언트는 클래스를 사용하며 알아야 하는 지식을 줄일 수 있고, 작성자는 파급효과 걱정을 하지 않고, 내부 구현을 마음대로 변경할 수 있음.
6. 객체의 데이터(인스턴스 변수)를 처리하는 메서드는 언제나 해당 객체가 가지고 있는 게 좋음. 이러면 응집도가 증가함.
7. 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이 핵심임. 클라이언트는 메시지 수신 객체가 메시지에 응답할 수 있다는 것만 알면 됨. 메시지에 응답할 수 있다는 것은 인터페이스를 통해 확인하는 것임.
8. 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킴.
9. 코드 수정을 회피하려는 이유는 두려움이며, 두려움은 변경으로 인해 버그가 생길지 모른다는 불확실성에서 기인함. 따라서 우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드임.
10. 대부분의 사람들은 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 고민함. 이것은 객체지향의 본질과는 거리가 멀고, 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있음. 이를 위해 두가지에 집중해야 함.

```
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라.
```

10. 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 함. 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현해야 함.
11. 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게 해야 함.
12. 클래스의 내부와 외부를 구분해야 하는 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문임. 그리고 해당 객체를 사용하는 클라이언트는 상세정보를 알 필요 없어서 좋고, 개발자는 구현부를 유출하지 않아서 구현의 자유를 얻음.
13. 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 점임. 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현해야 함(ex Money vs Long). 그 개념이 비록 하나의 인스턴스 변수만 포함하더라도, 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음임.
14. 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 좋지 않은 선택임. 항상 예외케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택해야 함(ex NoneDiscountPolicy).
15. NoneDiscountPolicy라는 새로운 클래스를 추가하는 것만으로 애플리케이션의 기능이 확장된 것처럼, 추상화를 중심으로 코드의 구조를 설계하면, 유연하고 확장 가능한 설계를 만들 수 있음.
16. 추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는 것을 방지하기 때문임.
17. 유연성이 필요한 곳에 추상화를 사용하라.
18. 코드 재사용을 위해서는 상속보다 합성이 더 좋음. `합성`은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말함.
19. 상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이지만, 두 가지 관점에서 설계에 안좋은 영향을 끼침.

```
1. 상속은 캡슐화를 위반함(부모 클래스의 내부 구조를 잘 알아야 함).
2. 상속은 설계를 유연하지 못하게 만듦(실행 시점에 객체의 종류 변경 불가능함).
```

20. 합성은 위의 두 문제를 모두 해결하는데, 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하므로, 구현을 효과적으로 캡슐화할 수 있음. 또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만듦.
21. 그렇다고 상속을 절대 사용하지 말라는 뜻이 아닌데, 대부분의 설계에서는 상속과 합성을 함께 사용해야 함.
22. 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것임.
23. 객체지향 패러다임의 관점에서 핵심은 역할, 책임, 협력임.
24. 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현(클래스,상속)에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 됨.
25. 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것임.
26. 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력임. 객체의 상태를 결정하는 것은 객체의 행동임.
27. 따라서 협력은 객체를 설계하는 데 필요한 일종의 `문맥`을 제공함.
28. 객체가 협력에서 어떠한 책임(or 역할)을 맡는지 판단하는 게 해당 객체 설계의 첫단계임.
29. 객체의 책임은 객체가 `무엇을 알고 있는가`와 `무엇을 할 수 있는가`로 구성됨. 예를 들어 Screening은 영화를 예매할 수 있어야 하며, 자신이 상영할 영화(의존성 객체)를 알고 있어야 함.
30. 책임과 메시지의 크기는 다른데, 책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로 더 큼. 하나의 객체가 수행할 수 있다고 생각했던 책임이 나중에는 여러 객체들이 협력해야만 하는 커다란 책임으로 자라는 것이 일반적임.
31. 협력이 중요한 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문임. 객체지향 설계에서 가장 중요한 것은 책임이고, 객체에게 얼마나 적절한 책임을 할당했느냐가 설계의 전체적인 품질을 결정함. 객체의 구현 방법은 상대적으로 책임보다는 덜 중요하며, 책임을 결정한 다음에 고민해도 늦지 않음.
32. CRC카드에서 CRC는 후보-책임-협력을 가리키며, 후보는 클래스,객체,컴포넌트,역할 어떤 것이라도 될 수 있음. CRC카드는 역할을 식별하고, 책임을 할당하며, 협력을 명시적으로 표현하는 구체적이면서도 실용적인 설계 기법임. 협력과 책임을 설계할 때, CRC카드를 사용하면 좋을 듯함.
33. 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것임. 이를 책임 할당을 위한 `정보 전문가 패턴`이라고 부름.
34. 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 보는 것임. 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰나감. 즉, 최초의 책임을 시스템(애플리케이션)이 제공하는 기능으로 두는 것임.
35. 협력을 위한 메시지 설계가 우선이고, 해당 메시지를 처리할 객체를 선택하는 것이 그 뒤임.
36. 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어짐. 그리고 이런 메시지가 메시지를 수신할 객체의 책임을 결정함.
37. 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성함. 협력을 설계하면서 객체의 책임을 식별해 나가는 과정에서 최종적으로 얻게 되는 결과물은 시스템을 구성하는 객체들의 인터페이스와 오퍼레이션의 목록임.
38. 어떤 경우에는 응집도와 결합도의 관점에서 정보 전문가가 아닌 다른 객체에게 책임을 할당하는 것이 더 적절한 경우도 있음. 하지만 기본적인 전략은 책임을 수행할 정보 전문가를 찾는 것임. 정보 전문가에게 책임을 할당하는 것만으로도 상태와 행동을 함께 가지는 자율적인 객체를 만들 가능성이 높아지기 때문임.
39. 이처럼 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 `책임 주도 설계`라고 부름.
40. 다음은 책임 주도 설계 방법의 과정을 정리한 것임.

```
1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악함.
2. 시스템 책임을 더 작은 책임으로 분할함.
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당함.
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾음.
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 됨.
```

41. 책임 주도 설계는 자연스럽게 객체의 구현이 아닌 책임에 집중할 수 있도록 해줌.
42. 책임을 할당할 때 고려해야 하는 두 가지 요소로, 하나는 메시지가 객체를 결정해야 한다는 것이고, 다른 하나는 행동이 상태를 결정한다는 것임.
43. 메시지가 객체를 선택하게 해야 하는 두 가지 중요한 이유가 있음.

```
1. 객체가 최소한의 인터페이스를 가질 수 있게 됨.
2. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 됨.
```

44. 객체가 협력에 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동임. 객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것임. 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정하는 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해함. 객체의 내부 구현을 변경하면, 퍼블릭 인터페이스도 함께 변경되게 됨. 이런 식으로 객체의 내부 구현에 초점을 맞춘 설계 방법을 `데이터 주도 설계`라고 부름.
45. 개별 객체의 상태와 행동이 아닌 시스템의 기능을 구현하기 위한 협력에 초점을 맞춰야만 응집도가 높고 결합도가 낮은 객체들을 창조 할 수 있음.
46. 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 `역할`이라고 부름. 실제로 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는 게 좋음.
47. 역할은 단순하게 객체을 추상화하여 같은 책임을 수행하는 여러 객체들을 담을 수 있는 슬롯으로 생각해도 됨.
48. 메시지 발신 -> 역할 찾기 -> 역할수행 객체 선택 으로 진행됨.
49. 역할에 맞는 객체가 하나뿐이라면, 역할=객체 라고 생각해도 됨.
50. 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있음.
51. 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장에 용이한 유연한 설계로 나아가는 첫걸음임.
52. 인터페이스 업캐스팅, 다형성, 동적바인딩, 상속 등과 같은 기술적 메커니즘들이 모여 유연하고 재사용 가능한 협력을 만들 수 있는 기반을 제공함.
53. 명확한 기준을 세우기 어렵고 정보가 부족한 설계 초반에는 어떤 것이 역할이고, 객체인지 결정을 내리기가 어려울 것임. 또한 도메인 모델 안에는 개념과 객체와 역할이 어지럽게 뒤섞여 있으며, 이것은 사람들이 세계를 바라보는 일반적인 관점임. 이에 대해서 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야 하고, 역할과 객체를 명확하게 구분하는 것은 그리 중요하지 않음. 따라서 애매하다면 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할(추상화)를 분리해내는 것이 가장 좋은 방법임.
54. 설계 초반에 다루는 대부분의 대상은 CRC카드를 설명할 때 언급했던 후보로 취급하는 게 합리적임. 후보는 객체, 역할, 클래스가 될 수 있으며 정확하게 무엇인지 설계 초반에는 그다지 중요하지 않고, 이 시점에서 중요한 것은 협력을 위해 어떤 책임이 필요한지를 이해하는 것임.
55. 다양한 객체들이 협력에 참여한다는 것이 확실하면 역할로 시작하고, 정확한 결정을 내리기 어려운 상황이라면 구체적인 객체로 시작하는 게 좋음.
56. 협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용 가능해짐.
57. 객체지향 커뮤니티에서 오랜 기간 동안 좋은 설계의 특징을 판단할 수 있는 기준에 관해 논의했는데 캡슐화, 응집도, 결합도를 주로 사용함.
58. 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공해주기 때문임. 객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있음. 변경될 가능성이 높은 부분은 구현이라고 부르고 상대적으로 안정적인 부분을 인터페이스라고 부름. 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것임.
59. 객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것임.
60. 응집도는 모듈에 포함된 내부 요소(ex 인스턴스 변수, 메서드)들이 연관돼 있는 정도를 나타내고 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가짐. 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있음. 간단히 말해 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고 모듈의 일부만 변경된다면 응집도가 낮은 것임. 또한 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮은 것임.
61. 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도는 낮다고 말함. 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 됨. `단일책임 원칙`은 클래스는 단 한 가지의 변경 이유만을 가져야 한다는 설계 원칙임.
62. 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도임. 변경의 관점에서 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있음.
63. 캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아짐.
64. getter, setter를 함부로 쓰면 안좋은게 퍼블릭 인터페이스에 인스턴스 변수명이 제대로 노출됨.
65. 객체에게 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드임.
66. 다른 객체에게 접근자 메서드를 통해 값을 변경할 기회를 주지 말고, 본인이 직접 바꿀 수 있도록 해야 캡슐화가 이루어짐. 객체는 단순한 데이터 제공자가 아님.
67. 인터페이스(not Interface, 의존성 객체의 메서드 부분)의 파라미터, 반환값, getter등을 통해서 내부 속성을 유추할 수 있고, 속성값 변경이 메서드의 파라미터 수정을 요구, 메서드 사용부분 전부 수정등으로 파급효과가 발생하므로 캡슐화가 부족하다고 판단됨. 또한 메서드 네임명으로 객체의 속성값이 유추될 수도 있음.
68. 캡슐화란 변할 수 있는 어떤 것이라도 감추는 것임. 그것이 속성의 타입이건, 할인 정책의 종류건 상관없이 내부 구현 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것임.
69. 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 함. 객체가 내부에 어떤 상태를 가지고 그 상태를 관리하는가는 부가적인 문제이고, 중요한 것은 객체가 다른 객체와 협력하는 방식임.
70. 책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 어떤 객체에게 어떤 책임을 할당할지를 결정하기 쉽지 않다는 것임. 책임 할당 과정은 일종의 트레이드 오프 활동이므로 동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라짐. 따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 함.
71. 객체에게 어떤 책임을 할당해야 하는가에 대한 실마리는 협력에서 찾을 수 있음. 객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정됨. 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 함.
72. 협력을 시작하는 주체는 메시지 전송자이기 때문에 협력에 적합한 책임이란 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미함. 다시 말해서 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 하는 것임.
73. 협력에 적합한 책임을 수확하기 위해서는 객체를 결정한 후에 메시지를 선택하는 것이 아니라 메시지를 결정한 후에 객체를 선택해야 함. 메시지가 객체를 선택하게 해야 하는 것임.
74. 메시지기반 설계 관점은 클래스기반의 설계 관점보다 훨씬 유연한 애플리케이션을 만들 수 있게 해줌. 클래스기반의 설계 관점이란 클래스를 결정하고 그 클래스의 책임을 찾아 나서는 것을 말함.
75. 메시지를 먼저 결정하기 때문에 메시지 송신자는 메시지 수신자에 대한 어떠한 가정도 할 수 없음. 메시지 전송자의 관점에서 메시지 수신자가 깔끔하게 캡슐화되는 것임.
76. 올바른 객체지향 설계는 클라이언트가 전송할 메시지를 결정한 후에야 비로소 객체의 상태를 저장하는 데 필요한 내부 데이터에 관해 고민하기 시작함.
77. GRASP 패턴은 책임 할당의 어려움을 해결하기 위한 답을 제시해줌. General Responsibility Assignment Software Pattern의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것임.
78. 설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용함. 도메인 안에는 무수히 많은 개념들이 존재하며 이 도메인 개념들을 책임 할당의 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 좀 더 수월해짐. 따라서 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념임. 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요는 없음. 이 단계에서는 책임을 할당받을 객체들의 종류와 관계에 대한 유용한 정보를 제공할 수 있다면 충분함. 중요한 것은 설계를 시작하는 것이지 도메인 개념들을 완벽하게 정리하는 것이 아님. 도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행해야 함.
79. 메시지는 메시지를 수신할 객체가 아니라 메시지를 전송할 객체의 의도를 반영해서 결정해야 함. 따라서 첫 질문은 다음과 같음. `메시지를 전송할 객체는 무엇을 원하는가?`
80. 두번째 질문은 다음과 같음. `메시지를 수신할 적합한 객체는 누구인가?`
81. 객체의 책임과 책임을 수행하는 데 필요한 상태는 동일한 객체 안에 존재해야 함. 따라서 객체에게 책임을 할당하는 첫번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 할당하는 것임. GRASP에서 이를 `정보전문가 패턴`이라고 부름.
82. 책임을 수행하는 객체가 정보를 알고 있다고 해서 그 정보를 저장하고 있을 필요는 없음. 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있음.
83. 설계 초반부에는 도메인 개념에서 정보전문가에 맞는 객체를 찾는 게 좋음.
84. 메시지를 수신할 객체가 스스로 처리할 수 없는 작업이 있다면 메시지로 도움을 요청해야 하고 메시지는 새로운 객체의 책임으로 할당됨. 이 같은 연쇄적인 메시지 전송과 수신을 통해 협력 공동체가 구성되는 것임.
85. 정보전문가 패턴은 객체에게 책임을 할당할 때 가장 기본이 되는 책임할당 원칙임. 이 패턴을 따르는 것만으로도 자율성이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아짐.
86. 설계는 트레이드오프 활동이기 때문에 동일한 기능을 구현할 수 있는 무수히 많은 설계가 존재함. 따라서 올바른 책임할당을 위해 정보전문가 패턴 이외의 다른 책임할당 패턴들을 함께 고려할 필요가 있음. 책임을 할당할 수 있는 다양한 대안들이 존재한다면 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 게 좋음. GRASP에서는 이를 `낮은 결합도 패턴`과 `높은 응집도 패턴`이라고 부름(ex DiscountCondition이 Movie와 협력하는 게 좋을까, 아니면 Screening과 협력하는 게 좋을까).
87. Movie와 DiscountCondition은 이미 결합되어 있기 때문에 Movie를 DiscountCondition과 협력하게 하면 설계 전체적으로 결합도를 추가하지 않고도 협력을 완성할 수 있음(낮은 결합도 패턴).
88. Screening이 DiscountCondition과 협력해야 한다면 Screening은 기존의 예매를 생성하는 책임에 영화 요금 계산과 관련된 책임 일부를 추가적으로 떠맡게 됨. 본인의 원래 책임외에 추가적인 책임이 생겨서 응집도가 떨어짐(높은 응집도 패턴).
89. 이처럼 책임을 할당하고 코드를 작성하는 매순간마다 낮은 결합도 패턴, 높은 응집도 패턴의 관점에서 전체적인 설계 품질을 검토하면 단순하면서도 재사용 가능하고 유연한 설계를 얻을 수 있을 것임.
90. GRASP의 `창조자 패턴`은 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공함.

```
객체 A를 생성해야 할때, 어떤 객체에게 객체 생성 책임을?
1. B가 A객체를 포함하거나 참조함.
2. B가 A객체를 기록함.
3. B가 A객체를 긴밀하게 사용함.
4. B가 A객체를 초기화하는데 필요한 데이터를 가지고 있음.
```

91. 이처럼 창조자 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것임. 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않음.
92. 협력과 책임이 제대로 동작하는지 확인할 수 있는 유일한 방법은 코드를 작성하고 실행해보는 것 뿐임. 올바르게 설계하고 있는지 궁금하면 코드를 작성해야 함.
93. Screening은 영화를 예매할 책임을 맡으며 그결과로 Reservation 인스턴스를 생성할 책임을 수행해야 함. 다시 말해 Screening은 예매에 대한 정보 전문가인 동시에 Reservation의 창조자임. 책임이 결정됐으므로 메시지를 처리할 수 있는 메서드를 구현하고 동시에 책임을 수행하는 데 필요한 인스턴스 변수를 결정해야 함.
94. 변경에 취약한 클래스란 코드를 수정해야 하는 이유를 하나 이상 가지는 클래스임. 예를 들어 코드 변경의 이유가 순번로직 변경, 기간로직 변경 두가지가 될 수 있음. 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮으며, 이를 해결하기 위해서는 변경의 이유에 따라 클래스를 분리해야 함.
95. 지금 본것처럼, 일반적으로 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋음. 문제는 갓 입문한 개발자들은 클래스 안에서 변경의 이유를 찾는 게 어렵다는 것인데, 변경 이유가 하나 이상인 클래스에 드러나는 패턴을 이해하고 나면 클래스 안에 숨겨진 변경의 이유를 생각보다 쉽게 알아낼 수 있을 것임.

```
1. 인스턴스 변수가 초기화되는 시점을 살펴봐라. 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 채로 냅둠.
2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴봐라. 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮은 것임.
```

96. 클래스를 분리할 때, 다형성을 통해 분리하는 게 좋음. 이때 역할의 개념이 등장하게 됨.
97. 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라는 것이 GRASP의 `다형성 패턴`임. 예를 들어 SequeceCondition, PeriodCondition같이 타입이 나누어지면 다형성 패턴을 적용함.
98. 다형성 패턴은 객체의 타입에 따라 여러 대안들을 수행하는 조건문적인 논리를 사용하지 말라고 경고하며 대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고함.
99. 변경을 캡슐화하도록 책임을 할당하는 것을 GRASP에서 `변경보호 패턴`이라고 함. 다형성 패턴을 쓰면 변경보호 패턴이 자동으로 적용됨. 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당해야 함.
100.  모든 인스턴스 변수는 private로 접근제한자를 설정하는 게 좋을 듯함.
101.  개발자로써 변경에 대비할 수 있는 두가지 방법은 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이고, 다른 하나는 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것임. 상속보다 합성을 사용하는 게 훨씬 변경에 용이함. 합성의 목적은 변경의 용이이며, 변경이 자주 발생하는 곳에 합성을 사용하는 게 좋음.
102.  코드의 구조가 바뀌면 도메인의 구조도 바뀌어야 함. 도메인 모델에 따라 코드의 모습을 정할 수 있으며, 코드의 모습에 따라 모델도 달라져야 함.
103.  여전히 책임을 할당하는 데 어려움을 느끼고 있다면 일단 절차형 코드로 실행되는 프로그램을 빠르게 작성한 후 완성된 코드를 객체지향적인 코드로 변경하는 `리팩토링 기법`을 사용해보는 게 좋음. 이 방법은 실무에서 많은 사람들이 사용하고 있음.
104.  절차형 코드로 작성할 때 발생하는 긴 메서드는 다양한 측면에서 코드의 유지보수에 부정적인 영향을 끼침. 긴 메서드는 응집도가 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어려움. 이러한 메서드를 `몬스터 메서드`라고 부름. 이러한 문제는 이해를 돕기 위해 주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높이는 게 해결책임. 클래스의 응집도와 마찬가지로 메서드의 응집도를 높이는 이유도 변경과 관련이 깊고 작은 메서드들로 조합된 메서드는 마치 주석들을 나열한 것처럼 보이기에 코드를 이해하기도 쉬움.
105.  해당 긴 메서드에서 여러 객체로 책임을 분배할 때 가장 먼저 할일은 메서드를 응집도 있는 수준으로 분해하는 것이고, 이렇게 분리하면 각 메서드를 적절한 클래스로 이동하기에 더 수월해짐.
106.  메서드를 이동할 때, 각 메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동시키면 됨. 어떤 데이터를 사용하는지를 가장 쉽게 알 수 있는 방법은 메서드 안에서 어떤 클래스의 접근자 메서드를 사용하는지 파악하는 것임.
107.  책임주도 설계방법에 익숙하지 않다면 일단 데이터 중심으로 구현한 후 이를 리팩토링하더라도 유사한 결과를 얻을 수 있음. 처음부터 책임주도 설계방법을 따르는 것보다 동작하는 코드를 작성한 후에 리팩토링하는 것은 더 훌륭한 결과물을 낳을 수도 있음.
108.  객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것임. 훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 함. 좀 더 정확하게 말해서 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 함. 여기서 중요한 것은 책임이 객체가 수신할 수 있는 메시지의 기반이 된다는 것임.
109.  애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 알아야 함.
110.  객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성함. 훌륭한 퍼블릭 인터페이스를 얻기 위해서는 책임주도 설계방법을 따르는 것만으로는 부족함. 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 익히고 적용해야 함.
111.  퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법이 있음.

```
1. 디미터 법칙
2. 묻지 말고 시켜라
3. 의도를 드러내는 인터페이스
4. 명령-쿼리 분리
```

112. 디미터 법칙은 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것임. 다시 말해 메시지를 전달하는 객체를 제한함.

```
1. this 객체
2. 메서드의 매개변수
3. this의 속성
4. this의 속성인 컬렉션의 요소
5. 메서드 내에서 생성된 지역 객체
```

113. 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송하는 것을 `기차 충돌`이라고 부름. 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 됨.
114. 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조함. `묻지 말고 시켜라`는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어임.
115. 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고민해야 함.
116. 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향샹시켜야 함. 협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 묻지 말고 시켜라 원칙과 디미터 법칙을 머릿속에서 떠올리는 것은 퍼블릭 인터페이스의 품질을 향상시킬 수 있는 좋은 습관임.
117. 훌륭한 인터페이스를 수확하기 위해서는 객체가 어떻게 작업을 수행하는지를 노출해서는 안됨. 인터페이스는 객체가 어떻게 하는지가 아니라 `무엇을 하는지`를 서술해야 함. 무엇을 하는지를 드러내는 이름은 코드를 읽고 이해하기 쉽게 만들뿐만 아니라 유연한 코드를 낳는 지름길임.
118. 어떻게 수행하는지를 드러내는 이름이란 메서드의 내부 구현을 설명하는 이름으로 결과적으로 협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민할 수밖에 없음. 반면 무엇을 하는지를 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 관해 고민하게 됨. 이것은 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 됨.
119. 또한 메서드가 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층(추상화)으로 묶을 수 있는 가능성이 커짐.
120. 하나의 구현을 가진 메시지의 이름을 일반화하도록 도와주는 간단한 훈련 방법이 있는데 매우 다른 두번째 구현을 상상하는 것임.
121. 디미터 법칙과 묻지 말고 시켜라 스타일을 따르면 자연스럽게 자율적인 객체로 구성된 협력을 얻게 됨.
122. 디미터 법칙과 묻지 말고 시켜라 스타일을 따르는 인터페이스를 얻었다면 인터페이스가 클라이언트의 의도를 올바르게 반영(표현)했는지를 확인해야 함. 이때, 오퍼레이션의 이름은 협력이라는 문맥을 반영해야 하는데 다시 말해 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야 함.
123. 이처럼 디미터 법칙과 묻지 말고 시켜라, 의도를 드러내는 인터페이스는 유연한 인터페이스 설계에 대한 방향성을 제시해줌.
124. 잊지 말아야 하는 사실은 설계가 트레이드오프의 산물이라는 점임. 설계를 적절하게 트레이드오프 할 수 있는 능력이 숙련자와 초보자를 구분하는 가장 중요한 기준이 됨. 초보자는 원칙을 맹목적으로 추종하지만 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시해야 함.
125. 트레이드오프 능력을 기르기 위해 위에서 설명한 원칙들을 적용할 때 고려해볼 만한 몇 가지 이슈가 있음.

```
1. 기차 충돌(도트(.))처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것임.
2. 디미터 법칙과 묻지 말고 시켜라 스타일을 준수하는 것은 항상 긍정적인 결과로만 귀결되는 것이 아님. 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션이 공존하게 됨. 결과적으로 응집도가 낮아지는 결과를 초래함. 단지 인스턴스 변수에 대한 getter만 사용하는 경우, 변수의 변경 이외에 파급효과는 발생하지 않으므로, 캡슐화가 조금 깨지긴 해도 위임 메서드로 발생하는 메시지 수신 객체의 변경요인 증가와 트레이드오프하여 우선권을 챙길 수 있음.
```

126. 가끔씩은 묻는 것 외에는 다른 방법이 존재하지 않는 경우도 존재함. 예를 들어 컬렉션에 포함된 객체들을 처리하는 유일한 방법은 객체에게 물어보는 것임. 이처럼 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달려 있음. 말하고자 하는 바는 객체에게 시키는 것이 항상 가능한 것이 아니고 가끔은 물어야 한다는 점임. 이는 트레이드오프에서 중요하게 생각해봐야 할 점임.
127. 가끔씩 필요에 따라 물어야 한다는 사실에 납득했다면 `명령-쿼리 분리 원칙`을 알아두면 도움이 됨. 명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공함.
128. `프로시저`는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없고, `함수`는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없음.
129. 객체의 상태를 수정하는 오퍼레이션을 `명령`이라고 부르고, 객체와 관련된 정보를 반환하는 오퍼레이션을 `쿼리`라고 부름. 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안됨.
130. 명령-쿼리 분리 원칙에 따라 작성된 객체의 인터페이스를 `명령-쿼리 인터페이스`라고 부름.
131. 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있음. 가장 깔끔한 해결책은 명령과 쿼리를 명확하게 분리하는 것임.
132. 명령-쿼리 인터페이스의 장점은 어떤 메서드가 부수효과를 가지는지를 확인하기 위해 코드를 일일이 다 분석하는 것보다는 메서드가 반환 값을 가지는지 여부만 확인하면 된다는 것임. 그 결과, 코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해질 것임. 즉, 객체의 부수효과를 제어하기가 수월해짐.
133. 쿼리 메서드를 어떤 순서로 몇 번 호출하건 상관없이 항상 결과는 동일할 것임.
134. 디미터 법칙을 준수하고 묻지 말고 시켜라 스타일을 따르면서도 의도를 드러내는 인터페이스를 설계하는 아주 쉬운 방법은 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것임.
135. 명령과 쿼리를 분리하고 계약에 의한 설계 개념을 통해 객체의 협력 방식을 명시적으로 드러낼 수 있는 방법은 객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것임.
136. 우리에게 중요한 것은 협력에 적합한 객체가 아니라 협력에 적합한 메시지임.
137. 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만듦. 따라서 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는 게 중요함. 이런 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술임.
138. interface의 자식 클래스가 interface에 의존하는 이유는 interface에 정의한 오퍼레이션들을 퍼블릭 인터페이스의 일부로 포함시키기 위해서임.
139. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해짐. 이를 `컨텍스트 독립성`이라고 부름. 런타임, 컴파일타임 의존성을 따로 두는 행위 자체가 컨텍스트 독립성을 증가시킴.
140. 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 `의존성 해결`이라고 부름. 의존성을 해결하기 위해서는 일반적으로 다음과 같이 세가지 방법을 사용함.

```
1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
2. 객체 생성 후 setter 메서드를 통해 의존성 해결
3. 메서드 실행 시 인자를 이용해 의존성 해결
```

141. setter 메서드를 이용하는 방법의 단점은 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에 객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있다는 점임. 따라서 더 좋은 방법은 생성자 방식과 setter방식을 혼합하는 것임.
142. 메서드 인자를 사용하는 방식은 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요없이 메서드가 실행되는 동안만 일시적으로 의존 관계가 존재해도 무방하거나, 메서드가 실행될 때마다 의존 대상이 매번 달라져야 하는 경우에 유용함. 하지만 클래스의 메서드를 호출하는 대부분의 경우에 매번 동일한 객체를 인자로 전달하고 있다면 생성자를 이용하는 방식이나 setter 메서드를 이용해 의존성을 지속적으로 유지하는 방식으로 변경하는 것이 좋음.
143. 바람직한 의존성은 재사용성과 관련 있음. 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것임. 다시 말해, 컨텍스트에 독립적인 의존성은 바람직한 의존성이고 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성임. 특정한 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용할 수 있는 유일한 방법은 구현을 변경하는 것 뿐임.
144. 결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정됨. 더 많이 알수록 더 많이 결합됨. 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요함. 이 목적을 달성할 수 있는 가장 효과적인 방법은 추상화임.
145. 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법임.
146. 구체 클래스 의존성 -> 추상 클래스 의존성 -> interface 의존성 순으로 결합도가 감소됨.
147. 결합도를 느슨하게 만들기 위해서는 인스턴스 변수의 타입을 추상 클래스나 interface로 선언하는 것만으로는 부족함. 클래스 안에서 구체 클래스에 대한 모든 의존성을 제거해야만 함.
148. 의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 안에서 직접 생성하는 방법 사이의 가장 큰 차이점은 퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는 지 여부임. 생성자,setter,메서드 인자로 설정하는 방법은 의존성이 명시적으로 퍼블릭 인터페이스에 노출됨. 이를 `명시적인 의존성`이라고 부름. 반면 메서드 내부에서 인스턴스를 직접 생성하는 방식은 의존한다는 사실을 감춤. 이를 `숨겨진 의존성`이라고 부름.
149. 숨겨진 의존성은 의존성 제거를 위해 의존성을 찾을 때 어렵게 만듦. 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없음.
150. 의존성은 명시적으로 표현되어야 함. 의존성을 구현 내부에 숨겨두면 안됨. 경계해야 할 것은 의존성 자체가 아니라 의존성을 감추는 것임.
151. new를 사용하면 클래스 사이의 결합도가 극단적으로 높아짐. new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 하고, 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 함. 따라서 new는 결합도를 높이기 때문에 해로움. 해결 방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것임. 외부에서 인스턴스를 전달받는 방법은 앞에서 살펴본 생성자,setter,메서드 인자를 사용함.
152. 사용과 생성의 책임을 분리하고, 의존성을 생성자에 명시적으로 드러내고, 구체 클래스가 아닌 추상 클래스에 의존하게 함으로써 설계를 유연하게 만들 수 있음. 그 출발은 객체를 생성하는 책임을 객체 내부가 아니라 클라이언트로 옮기는 것에서 시작했다는 점을 기억해야 함.
153. 가끔은 클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있음. 주로 협력하는 기본 객체를 설정하고 싶은 경우가 여기에 속함. 대부분의 경우에는 A의 인스턴스와 협력하고 가끔씩만 B의 인스턴스와 협력한다고 가정하면, 이런 상황에서 모든 경우에 인스턴스를 생성하는 책임을 클라이언트로 옮긴다면 클라이언트들 사이에 중복 코드가 늘어나고 사용성도 나빠짐. 이 문제를 해결하는 방법은 기본 객체 A를 생성하는 생성자를 추가하고 이 생성자에서 interface의 인스턴스를 인자로 받는 생성자를 체이닝하는 것임.

```
public Movie(String title, Duration runningTime, Money fee) {
  this(title, runningTime, fee, new AmountDiscountPolicy(...));
}
```

154. 이렇게 해도 결국 내부에서 new를 사용하기 때문에 결합도가 증가함. 하지만 클라이언트에서 발생하는 중복코드와 사용성 저하와 트레이드오프가 이루어지는 것임. 이 방법은 메서드를 오버로딩하는 경우에도 사용할 수 있음. 그럼에도 가급적 구체 클래스에 대한 의존성을 제거할 수 있는 방법을 찾아보는게 좋음. 종종 모든 결합도가 모이는 새로운 클래스를 추가함으로써 사용성과 유연성이라는 두마리 토끼를 잡을 수 있는 경우가 있는데, FACTORY가 바로 그런 경우임.

```
public Money calculateMovieFee(Screening screening) {
  return calculateMovieFee(screening, new AmountDiscountPolicy(...));
}
```

155. 자바JDK에 포함된 표준 클래스는 변경될 확률이 거의 없으므로 의존성이 문제가 되지 않음. 이런 클래스들에 대해서는 구체 클래스에 의존하거나 직접 인스턴스를 생성하더라도 문제가 없음(ex new ArrayList<>()).
156. 비록 클래스를 직접 생성하더라도 가능한 한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리함(ex List).
157. 예외케이스를 처리하기 위해 코드 내부를 직접 수정하는 것은 안좋음. 해결책은 할인 정책이 존재하지 않는다는 사실을 예외케이스로 처리하지 말고 NoneDiscountPolicy 클래스를 추가하는 것처럼 기존에 Movie와 DiscountPolicy가 협력하던 방식을 따르는 것임. 비슷하게, 중복 할인 정책을 할인 정책의 한 가지로 간주함으로써도 해결가능함.
158. 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지를 쉽게 파악할 수 있음. 코드에 드러난 로직을 해석할 필요없이 객체가 어떤 객체와 연결됐는지를 보는 것만으로도 객체의 행동을 쉽게 예상하고 이해할 수 있기 때문임.
159. 훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계임.
160. 변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼는 것임. 추상화가 수정에 대해 닫혀 있을 수 있는 이유는 변경되지 않을 부분을 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이라는 사실을 기억해야 함.
161. 메시지 수신 객체에서 사용할 인스턴스를 만들 책임이 클라이언트에게 새어나가 클라이언트도 특정한 컨텍스트에 묶이기를 바라지 않을 때, FACTORY를 사용함. 객체 생성에 특화된 FACTORY클래스를 구현하여, factory객체를 주입받아 factory객체가 생성해주는 인스턴스를 받아 사용하는 것임. 이렇게 FACTORY를 사용하면 인스턴스를 생성하는 책임 모두를 FACTORY로 이동할 수 있음.
162. 책임 할당의 가장 기본이 되는 원칙은 정보전문가 패턴인데, 이를 위해 도메인 모델 안의 개념 중에서 후보를 찾게 됨. 그러나 종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 발생함. 실제로 동작하는 애플리케이션은 데이터베이스 접근을 위한 객체와 같이 도메인 개념들을 초월하는 기계적인 개념들을 필요로 할 수 있음. 모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제점에 봉착할 가능성이 높아짐. 이 경우 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결해야 함. 이러한 도메인과 무관한 인공적인 객체를 `순수한 가공물`이라고 부름. factory객체가 이에 속함.
163. 어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면, 순수한 가공물을 추가하고 이 객체에게 책임을 할당해야 함.
164. 설계자로서의 우리의 역할은 도메인 추상화를 기반으로 애플리케이션 로직을 설계하는 동시에 품질의 측면에서 균형을 맞추는 데 필요한 객체들을 창조하는 것임. 먼저 도메인의 본질적인 개념을 표현하는 추상화를 이용해 애플리케이션을 구축하기 시작하고, 도메인 개념이 만족스럽지 못하다면 주저하지 말고 인공적인 객체를 창조해야 함.
165. 도메인 객체에 책임을 할당할 경우 높은 응집도, 낮은 결합도 재사용성 등의 목적을 위반한다면, 도메인 개념을 표현하지 않는 인위적으로 만든 클래스에 매우 응집된 책임을 할당해야 함. 이처럼 순수한 가공물 패턴은 정보전문가 패턴에 따라 책임을 할당한 결과가 바람직하지 않을 경우 대안으로 사용됨.
166. 잘 설계된 객체지향 애플리케이션에서는 interface의 소유권을 서버가 아닌 클라이언트에 위치시킴. 전통적인 패러다임에서는 interface가 하위 수준 모듈에 속했다면 객체지향 패러다임에서는 interface가 상위 수준 모듈에 속하는 것임.
167. 설계의 유연함은 단순성과 명확성의 희생 위에서 자라남. 불필요한 유연성은 불필요한 복잡성을 낳으므로, 단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하는 게 좋음. 하지만 복잡성에 대한 걱정보다 유연하고 재사용 가능한 설계의 필요성이 더 크다면 코드의 구조와 실행 구조를 다르게 만드는 게 좋음.
168. 역할과 객체가 일치한다면, 굳이 유연성을 챙길 필요가 없음. 초보자가 자주 저지르는 실수 중 하나는 객체의 역할과 책임이 자리를 잡기 전에 너무 성급하게 객체 생성에 집중하는 것임. 이것은 객체 생성과 관련된 불필요한 세부사항에 객체를 결합시킴. 중요한 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것보다 우선임. 책임의 불균형이 심화되고 있는 상태에서 객체의 생성 책임을 지우는 것은 설계를 하부의 특정한 메커니즘에 종속적으로 만들 확률이 높음.
169. 민첩하게 변경하기 위해서는 중복 코드를 추가하는 대신 제거해야 함. 기회가 생길 때마다 코드를 DRY하게 만들기 위해 노력해야 함.
170. 자식 클래스의 메서드 안에서 super참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합됨. 따라서 super호출을 제거할 수 있는 방법을 찾아 결합도를 제거해야 함.
171. 상속관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 가리켜 `취약한 기반 클래스 문제`라고 부름.
172. 객체지향의 핵심은 객체들의 협력임. 상속으로 단순히 코드를 재사용하기 위해 불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안됨.
173. 상속계층이 코드를 진화시키는 데 걸림돌이 된다면 추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩토링해야 함. 다시 말해 부모 자식 관계의 클래스들을 추상 클래스의 자식클래스로 바꾸는 것임.
174. 또한 추상화를 적용하면서 클래스들의 이름을 의도를 드러내는 이름으로 바꿔줘야 함.
175. 변경에 유연하게 대처할 수 있는 설계가 대부분의 경우에 정답일 가능성이 높음.
176. 코드 재사용을 위해서는 객체 합성이 클래스 상속보다 더 좋은 방법임.
177. 합성을 사용하면 상속이 초래하는 세 가지 문제점을 해결할 수 있음.

```
1. 불필요한 인터페이스 상속 문제 : 자식 클래스에게 부적합한 부모 클래스의 오퍼레이션이 상속됨.
2. 메서드 오버라이딩의 오작용 문제 : 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 때, 해당 오버라이딩 메서드를 사용하는 부모 클래스의 메서드에 영향을 받는 문제가 발생함.
3. 부모 클래스와 자식 클래스의 동시수정 문제 : 부모 클래스를 변경할 때 자식 클래스도 함께 변경해줘야 함.
```

178. 상속을 합성으로 바꾸는 방법은 매우 간단한데 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 됨.
179. 대부분의 경우 구현에 대한 결합보다 인터페이스에 대한 결합이 더 좋음.
180. 클래스 내 특정 메서드(stat)에서 자신의 메서드(getEvaluationMethod)를 호출한다는 표현은 적절하지 않음. getEvaluationMethod()라는 구문은 현재 클래스의 메서드를 호출하는 것이 아니라 현재 객체에게 getEvaluationMethod 메시지를 전송하는 것임. 현재 객체란 바로 self참조가 가리키는 객체임. 메서드 탐색은 처음에 메시지 탐색을 시작했던 self참조가 가리키는 바로 그 클래스에서부터 다시 시작하게 됨.
181. self전송은 자식 클래스에서 부모 클래스 방향으로 진행되는 동적 메서드 탐색 경로를 다시 self참조가 가리키는 원래의 자식 클래스로 이동시킴.
182. super참조의 정확한 의도는 '지금 이 클래스의 부모 클래스에서부터 메서드 탐색을 시작하세요'임. 만약 부모 클래스에서 원하는 메서드를 찾지 못한다면 더 상위의 부모 클래스로 이동하면서 메서드가 존재하는지 검사함. 이것은 super참조를 통해 실행하고자 하는 메서드가 반드시 부모 클래스에 위치하지 않아도 되는 유연성을 제공함.
183. 이처럼 super참조를 통해 메시지를 전송하는 것은 마치 부모 클래스의 인스턴스에게 메시지를 전송하는 것처럼 보이므로 이를 `super전송`이라고 부름.
184. self전송이 메시지를 수신하는 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정하는 데 비해 super전송은 항상 메시지를 전송하는 클래스의 부모 클래스에서부터 시작됨. 따라서 super전송의 경우에는 컴파일 시점에 미리 결정해놓을 수 있음.
185. 메서드 탐색 중에는 자식 클래스의 인스턴스와 부모 클래스의 인스턴스가 동일한 self참조를 공유하는 것으로 봐도 무방함.
186. GradeLecture의 stats 메서드는 메시지를 직접 처리하지 않고 Lecture의 stats 메서드에게 요청을 전달함. 이처럼 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것을 위임이라고 함. 상속계층을 따라 메서드 탐색과정이 상위 클래스로 올라갈 때마다 this도 함께 전달해주는 것도 위임에 포함됨.
187.

### 개념

1. 글래스는 이론과 실무의 우선순위에서 이론보다 실무가 먼저라고 함. 소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 실무에 초점을 맞추는 것이 효과적임.
2. 추상적인 개념과 이론은 훌륭한 코드를 작성하는 데 필요한 도구일 뿐임.
3. 로버트 마틴이 '클린 소프트웨어'에서 언급한 소프트웨어 모듈이 가져야 하는 세 가지 기능으로 제대로 실행되어야 함, 변경이 용이해야 함, 이해하기 쉬워야 함 을 들었음.
4. 티켓판매소 예시의 문제점은 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점에서 우리의 상식과 다르게 동작하므로 이해가 잘 안되고, 소극장이 관람객과 판매원에 직접 접근한다는 점에서 강한 결합도를 가지게 되어 변경이 어려워진다는 점임.
5. 위의 변경이 어려워지는 부분에서 의존성이 관련된 문제이고, 과한 의존성은 결합도를 높히게 됨. 하지만 이러한 의존성을 완전히 없애는 것이 정답이 아니라, 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것을 목표로 두어야 함.
6. 티켓판매소 예시에서의 노이해, 변경불용이 문제를 해결하는 방법은 간단하게도, 소극장이 관람객과 판매원에 관해 세세한 부분까지 알지 못하도록 정보를 차단하는 것임. 또한 관람객과 판매원이 스스로 일을 할 수 있는 자율성을 부여하면 됨.
7. 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 함. 캡슐화를 통해 객체 내부로의 접근을 제한하면, 객체 사이의 결합도를 낮출 수 있으므로 설계 변경이 좀 더 용이해짐.
8. 특정 클래스를 캡슐화 하기 위해서는 다른 클래스가 해당 클래스에 직접 접근하는 부분을 전부 해당 클래스가 내부적으로 수행하도록 변경함.
9. 객체의 자율성을 높이는 방향으로 설계를 개선하면, 이해하기 쉽고 유연한 설계를 얻을 수 있음.
10. 프로세스(메서드), 데이터(인스턴스 변수)를 별도의 모듈에 위치시키는 방식을 `절차적 프로그래밍`이라고 부름.
11. 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 `객체지향 프로그래밍`이라고 부름.
12. 현실에서는 수동적인 존재라고 하더라도, 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀜. 이를 의인화라고 부름.
13. 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 `도메인`이라고 부름.
14. 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있음.
15. 클래스의 구조는 도메인의 구조와 유사한 형태를 띄어야 함.
16. 설계된 도메인을 바탕으로 클래스 구조를 작성해야 하고, 클래스 명은 도메인 개념의 이름과 유사하게 지어야 함.
17. 객체가 자율적인 존재로 우뚝서기 위해서는 외부의 간섭을 최소화해야 함.
18. 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이고, 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라고 부름.
19. 메시지 수신 객체가 메시지를 처리하는 방법(메서드)을 자율적으로 결정함.
20. 유사한 클래스를 관리하기 위해 상속, 특히 추상클래스와 인터페이스를 사용함.
21. 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 `Template Method`라고 함.
22. 인터페이스의 공유만 필요한 경우 interface를 사용하고, 구현의 공유가 추가적으로 필요한 경우 abstract class를 사용함.
23. 대부분의 사람들은 상속의 목적이 메서드나 인스턴스 변수를 재사용 하는 것이라고 생각하지만, 상속을 통해 부모 클래스의 인터페이스를 물려받아 부모 클래스 대신 사용될 수 있다는 점이 더 중요함.
24. 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 `구현 상속`이라고 하며, 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 `인터페이스 상속` 이라고 함. 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 함.
25. 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 함.
26. 코드 상에서와 달리 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라짐. 이를 `다형성`이라고 함.
27. 다형성은 객체지향 프로그램의 컴파일타임 의존성과 런타임의존성이 다를 수 있다는 사실에 기반으로 함. 객체지향은 동적 바인딩을 사용하므로, 다형성의 활용이 가능한 것임.
28. 메시지와 메서드를 실행 시점에 바인딩 하는 것을 `동적 바인딩`이라고 하고, 컴파일 시점에 바인딩 하는 것을 `정적 바인딩`이라고 함.
29. 추상화를 사용할 경우 두가지 장점을 누릴 수 있음.

```
1. 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있음.
2. 추상화를 이용하면 설계가 좀 더 유연해짐.
```

30. 추상화의 첫번째 장점을 통해, 추상화를 사용해 애플리케이션의 협력흐름을 상위정책으로 기술할 수 있으며, 간략한 기술 덕에 새로운 기능을 쉽게 추가할 수 있음.
31. 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라 함. 객체가 협력에 참여하기 위해 수행하는 로직을 책임이라고 함. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할(추상화)을 구성함.
32. 메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단임.
33. 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상시킬 수 있음. 자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청함. 메시지 수신 객체 역시 메시지를 처리하던 중에 직접 처리할 수 없는 정보나 행동이 필요한 경우 또 다른 객체에게 도움을 요청함. 이처럼 객체들 사이의 협력을 구성하는 `일련의 요청과 응답의 흐름`을 통해 애플리케이션의 기능이 구현됨.
34. 객체지향 설계에서는 상태를 분할의 중심축으로 삼는 방법, 책임을 분할의 중심축으로 삼는 방법 두 가지가 있음. 데이터 중심의 관점은 객체의 상태에 초점을 맞추고, 책임 중심의 관점은 객체의 행동에 초점을 맞춤. 훌륭한 객체지향 설계는 데이터가 아닌 책임에 초점을 맞춰야 함. 객체의 상태는 구현에 속하고 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너짐. 그에 비해, 객체의 책임을 중심축으로 삼으면, 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써, 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지할 수 있음.
35. 책임중심 설계는 `책임이 무엇인가`를 묻는 것으로 시작한다면 데이터중심 설계는 객체가 내부에 저장해야 하는 `데이터가 무엇인가`를 묻는 것으로 시작함. 책임을 명확히하고 분리하는 작업을 안했으니 관련있을 법한 데이터를 다 때려박는 수밖에 없음. 또한 객체가 무엇을 할 것인가 결정하기 전에 객체가 가져야 할 데이터를 설계함.
36. 데이터중심 설계가 가진 대표적인 문제점은 캡슐화 위반, 높은 결합도, 낮은 응집도임.
37. 데이터에 초점을 맞추게 되면 getter,setter처럼 오퍼레이션 명에 데이터 이름이 들어가게 됨. 또한 `누가 이 객체의 ~를 사용할거야`처럼 협력에 관해 고민하지 않아 협력을 파악하지 못하니 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있도록 최대한 많은 무분별한 접근자 메서드가 추가됨.
38. 이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 `추측에 의한 설계 전략`이라고 부름. 따라서 프로그래머는 내부 상태를 드러내는 메서드를 최대한 많이 추가해야 한다는 압박에 시달릴 수 밖에 없으며 결과적으로 대부분의 내부 구현이 퍼블릭 인터페이스에 그대로 노출될 수 밖에 없음. 그 결과, 캡슐화의 원칙을 위반하는 변경에 취약한 설계를 얻게 됨.
39. 이처럼 데이터중심 설계는 객체의 캡슐화를 약화시키기 때문에 클라이언트가 객체의 구현에 강하게 결합됨. 결합도 측면에서 데이터 중심 설계가 가지는 또 다른 단점은 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합될 수 밖에 없음.
40. 데이터중심 설계가 변경에 취약한 이유는 두가지임.

```
1. 데이터중심 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요함.
2. 데이터중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정함.
```

41. 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성됨. 하나는 객체가 수신하는 메시지의 집합이고 다른 하나는 외부의 객체에게 전송하는 메시지의 집합임. 대부분의 사람들은 객체가 수신하는 메시지에 초점을 맞추지만 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직함.
42. 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 함.
43. 메시지는 오퍼레이션명과 인자로 구성되며, 메시지 전송은 여기에 메시지 수신자를 추가한 것임. 또한 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려있음.
44. 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 함. 또한 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부름. 실제 실행되는 코드인 메서드와는 별개임.
45. 오퍼레이션과 파라미터 목록을 합쳐서 시그니처라고 부름.
46. 부수효과를 기반으로 하는 프로그래밍 방식을 `명령형 프로그래밍`이라고 부름. 반면에 `함수형 프로그래밍`은 부수효과가 존재하지 않는 수학적인 함수에 기반함. 하드웨어의 발달로 병렬처리가 중요해진 최근에는 함수형 프로그래밍의 인기가 상승하고 있음.
47. 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 `개방-폐쇄 원칙(OCP)`라고 부름.
48. `의존성 전이`가 의미하는 것은 다른 객체에 의존할 경우, 다른 객체가 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것임. 의존성은 전이가 될 수 있기 때문에 의존성의 종류를 `직접 의존성`과 `간접 의존성`으로 나누기도 함.
49. 의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성임.
50. 의존성과 관련해서 다뤄야 하는 또 다른 주제는 `런타임 의존성`과 `컴파일타임 의존성`의 차이임. 런타임은 간단하게 애플리케이션이 실행되는 시점이지만, 컴파일타임은 약간 미묘함. 일반적으로 컴파일타임이란 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가리키기도 함. 따라서 어딘가에서 컴파일타임이라는 용어를 보게 된다면 그것이 정말 컴파일이 진행되는 시점을 가리키는 것인지 아니면 코드를 작성하는 시점을 가리키는 것인지를 파악하는 게 중요함.
51. 객체지향 애플리케이션에서 런타임 의존성이 다루는 주제는 객체 사이의 의존성인 반면, 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성임. 여기서 중요한 것은 런타임 의존성과 컴파일타임 의존성이 다를 수 있다는 것임. 사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 함.
52. 유연하고 재사용 가능한 설계를 만들기 위해서는 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 함. 추상클래스(interface 포함)를 의존성으로 둬서 가능함.
53. 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어짐.
54. 의존성은 존재한다, 존재하지 않는다로 표현되고 결합도는 강하다, 느슨하다로 표현됨.
55. 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 `의존성 주입`이라고 부름.
56. 의존성 주입에서는 생성자 주입, setter 주입, 메서드 주입처럼 의존성을 해결하는 세가지 방법을 가르키는 별도의 용어를 정의함.
57. 변경이 빈번한 클래스(하위수준)들의 패키지와 변경이 빈번하지 않은 클래스(상위수준)들의 패키지를 분리해야 하는데, 패키지 내의 어떤 클래스가 수정되더라도 패키지 전체가 재배포되어야 하기 때문임. 또한 클라이언트의 재사용에 필요한 것이 의존성 관계에 있는 interface뿐이라 분리시켜야 하기도 함. 이처럼 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 함. 그리고 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 함. 이 기법을 가리켜 `분리된 인터페이스 패턴`이라고 함. 클라이언트와 추상 클래스를 하나의 패키지로 모으는 것은 클라이언트를 특정한 컨텍스트로부터 완벽하게 독립시킴.
58. 중복 코드는 변경을 방해함. 중복 코드가 가지는 가장 큰 문제는 코드를 수정하는 데 필요한 노력을 몇 배로 증가시킨다는 것임. 중복 여부를 판단하는 기준은 변경임. 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드들은 중복임. 중복 코드를 결정하는 기준은 코드의 모양이 아님. 프로그래머들은 `DRY 원칙`을 따라야 하는데, Dont Repeat Yourself라는 반복하지 말라는 뜻임.
59. 중복 코드는 항상 함께 수정돼야 하기 때문에 수정할 때 하나라도 빠트린다면 버그로 이어질 것임.
60. 두 클래스 사이의 중복 코드를 제거하기 위해 클래스에 타입 코드를 추가하고 타입 코드 값에 따라 로직을 분기시키는 방법은 if-else문을 사용하기 때문에 내부의 정보를 노출해야 해서 높은 결합도를 갖게 됨.
61. 중복 코드를 제거하기 위해 상속을 사용하면 부모 클래스와 자식 클래스 사이에 강한 결합이 생겨서 코드를 수정하기 어려워짐.
62. 상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 속속들이 알도록 강요함.
63. 상속의 강한 결합도 문제를 해결하는 가장 일반적인 방법은 자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만드는 것임. 그러나 완전히 없앨 수는 없음. 예를 들어 추상화 메서드 이름을 바꾸면 영향이 감.
64. 중복 코드를 제거할 때 가장 먼저 할 일은 중복 코드 안에서 차이점을 별도의 메서드로 추출하고(변하는 것으로부터 변하지 않는 것을 분리하라), 완전히 같은 부분을 추상 부모 클래스로 올리는 것임. 공통 코드를 옮길 때, 인스턴스 변수보다 메서드를 먼저 이동시키는 게 편한데, 메서드를 옮기고 나면 그 메서드에 필요한 메서드나 인스턴스 변수가 무엇인지를 컴파일 에러를 통해 자동으로 알 수 있기 때문임. 메서드가 동일하지 않았던 부분은 시그니처만 동일하므로, 시그니처만 부모 클래스로 이동시키고, 자식 클래스에서 해당 추상 메서드를 오버라이딩 할 수 있도록 해야 함.
65. 자식 클래스들 사이의 공통점을 부모 클래스로 옮김으로써 실제 코드를 기반으로 상속 계층을 구성할 수 있음. 공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경이유를 가지므로, 단일 책임 원칙을 준수하기 때문에 응집도가 높음.
66. 또한 자식 클래스들이 구현해야 하는 추상 메서드가 부모의 추상 메서드에 의존하고 있기 때문에 의존성 역전 원칙도 준수함.
67. 자식 클래스는 자신의 인스턴스를 생성할 때 부모 클래스에 정의된 인스턴스 변수를 초기화해야 하기 때문에 자연스럽게 부모 클래스에 추가된 인스턴스 변수는 자식 클래스의 초기화 로직에 영향을 미치게 됨. 하지만 인스턴스 초기화 로직을 변경하는 것이 두 클래스에 동일한 코드를 중복시키는 것 보다는 현명한 선택임.
68. 이처럼 상속을 통해 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 `차이에 의한 프로그래밍`이라고 부름.
69. 상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만들기 때문에 정말로 필요한 경우에만 상속을 사용해야 함.
70. 상속이 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는데 비해 `합성`은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용함. 상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일타임에 해결되지만 합성에서 두 객체 사이의 의존성은 런타임에 해결됨. 상속관계는 `is-a`관계라고 부르고 합성 관계는 `has-a`관계라고 부름. 상속관계는 클래스 사이의 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계임.
71. 이 차이는 중요한데, 코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만 합성 관계는 실행시점에 동적으로 변경할 수 있기 때문에 상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있음.
72. 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존함. 따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있음.
73. 코드 재사용의 목적으로 상속을 사용하면 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 함. 특히 기능의 조합을 수행하기 위해 A+B=AB 클래스처럼 수많은 조합된 클래스를 만들어야 함. 이를 `조합의 폭발 문제` 라고 부름. 합성을 사용하는 위 문제도 해결됨.
74. 부모와 자식 클래스 사이에 결합도를 느슨하게 하는 방법으로 자식 클래스에서 구현한 부모의 추상 메서드들이 부모 클래스의 메서드에 구현으로써 참여하게 하는 것임. 자식 클래스는 추상 메서드를 오버라이딩하고 자신만의 로직을 구현해서 부모 클래스에서 정의한 플로우에 개입할 수 있게 됨. 자식은 결국 부모의 추상 메서드를 구현할 뿐이므로 결합도가 많이 낮아짐.
75. 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드를 `훅 메서드`라고 함. 추상 클래스에서 이미 구현된 메서드를 말함.
76. 상속 관계는 컴파일타임에 결정되고 고정되며 실행하는 도중에 변경할 수 없기 때문에, 여러 기능을 조합해야 하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가해야 했지만 합성은 런타임타임에 결정되도록 할 수 있기 때문에 조합의 폭발 문제를 해결할 수 있음.
77. 추상클래스가 인터페이스를 구현하도록 하면, 추상클래스는 퍼블릭 인터페이스를 구현해야 하며, 자신도 직접 추상 메서드를 만들어서 자식들에게 떠넘길 수 있음. 내리갈굼과 비슷한 느낌임. 이렇게 하면, 해당 추상 클래스의 자식들을 인터페이스 합성으로 업캐스팅할 수 있음.
78. 합성의 진가는 새로운 클래스를 추가하거나 수정하는 시점이 돼서야 비로소 알 수 있음.
79. 상속을 사용해야 하는 경우는 상속이 구현 상속과 인터페이스 상속 두가지로 나눠진다는 사실을 알아야 이해할 수 있음. 다시 말하자면, 구현 상속을 피하고 인터페이스 상속을 사용해야 함.
80. 상속의 목적은 인터페이스 상속을 통해 타입 계층을 구조화하는 것임.
81. 매개변수 다형성은 제네릭 프로그래밍(Generic)과 관련이 높은데 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입(T,V)으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식을 가리킴. 포함(서브타입) 다형성은 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미함. 특별한 언급없이 다형성이라고 할 때는 포함 다형성을 의미하는 것이 일반적임.
82. 아래의 개념들을 이해하고 나면 상속의 내부 메커니즘뿐만 아니라 타입 계층을 기반으로 한 다형성의 동작 방식을 이해할 수 있게 됨.

```
1. 업캐스팅
2. 동적 메서드 탐색
3. 동적 바인딩
4. self 참조
5. super 참조
```

83. 자식 클래스의 생성자에서 부모 클래스의 생성자가 먼저 동작하여 부모 인스턴스가 먼저 생성되고 자식 인스턴스가 해당 인스턴스를 활용하는 것임. 이때, class area에는 부모클래스의 정보도 함께 로딩됨. self참조는 퍼블릭 인터페이스에 연결된 객체의 heap영역의 데이터를 가리키고, super참조는 해당 객체와 함께 생성된 부모 인스턴스의 데이터를 가리킴. 참고로 heap영역의 데이터에는 인스턴스 변수와 같은 데이터만 들어가고, 메서드 정보는 없음. 메서드 정보는 class area에 로딩된 class 정보를 통해 활용되는 것임.
84. 자식 클래스의 인스턴스에는 부모 클래스의 인스턴스로 접근 가능한 링크가 존재한다고 생각하면 됨. 따라서 부모 인스턴스의 변수를 직접적으로 사용할 수 있던 것임. 참고로 자식 클래스의 생성자에는 super생성자가 암묵적으로 들어가 있고, 여러 매개변수가 사용된다면 super를 통해 부모 생성자의 매개변수를 따로 명시해줘야 함.
85. 각 객체는 자신의 클래스의 위치를 가리키는 class라는 이름의 포인터를 가지며 이 포인터를 이용해 자신의 클래스 정보에 접근할 수 있음. 또한 클래스 정보에는 자신의 부모 클래스의 위치를 가리키는 parent라는 이름의 포인터도 들어있음.
86. 메시지를 수신한 객체는 class포인터로 연결된 자신의 클래스에서 적절한 메서드가 존재하는지를 찾고, 만약 메서드가 존재하지 않으면 클래스의 parent포인터를 따라 부모 클래스를 차례대로 훑어가면서 적절한 메서드가 존재하는지를 검색함.
87. 따라서 각 객체에 포함된 class포인터와 클래스에 포함된 parent포인터를 조합하면 현재 인스턴스의 클래스에서 최상위 부모 클래스(Object)에 이르기까지 모든 부모 클래스에 접근하는 것이 가능한 것임. 이 구조를 바탕으로 객체가 실행 시점에 메서드를 탐색한다고 보면 됨.
88. 코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라지는 것은 업캐스팅과 동적 바인딩이라는 메커니즘이 작용했기 때문임.
89. 동일한 코드라 하더라도 self참조가 가리키는 객체가 무엇인지에 따라 메서드 탐색을 위한 상속 계층의 범위가 동적으로 변함.
90. 객체지향에서는 객체가 수신할 수 있는 메시지를 기준으로 타입을 분류하기 때문에 동일한 퍼블릭 인터페이스를 가지는 객체들은 동일한 타입으로 분류할 수 있음. 다시말해, 객체의 퍼블릭 인터페이스가 객체의 타입을 결정함. 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류됨.
91. 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 `슈퍼타입`이라고 부르고, 더 특수한 타입을 `서브타입`이라고 부름.
92. 객체의 정의를 의미하는 내연 관점에서 일반화란 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정을 의미하고, 특수화란 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정을 의미함.
93. 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있음. 이것은 상속과 다형성의 관계를 이해하기 위한 출발점임.
94. 다음과 같은 질문을 해보고 두 질문에 모두 예 라고 답할 수 있는 경우에만 상속을 사용해야 함.

```
1. 상속관계가 is-a 관계를 모델링하는가?
2. (중요)클라이언트 입장에서는 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
```

95. 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 함. 이를 자식 클래스와 부모 클래스 사이의 `행동 호환성`이라고 부름.
96. 클라이언트의 관점에서 두 클래스에 대해 기대하는 행동이 다르다면 비록 그것이 어휘적으로 is-a 관계로 표현할 수 있다고 하더라도 상속을 사용해서는 안됨.
97. 어휘적으로 펭귄은 새지만 만약 새의 정의에 날 수 있다는 행동이 포함된다면 펭귄은 새의 서브타입이 될 수 없음. 따라서 어떤 두 대상을 언어적으로 is-a라고 표현할 수 있더라도 일단은 상속을 사용할 예비 후보 정도로만 생각해야 함. 너무 성급하게 상속을 적용하려고 서두르면 안됨.
98. 여기서 중요한 것은 행동의 호환 여부를 판단하는 기준은 `클라이언트의 관점`이라는 것임. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입계층으로 묶을 수 있음.
99. 행동 호환성을 만족시키지 않는 상속계층을 그대로 유지한 채 클라이언트의 기대를 충족시킬 수 있는 방법을 찾기란 쉽지 않음. 문제를 해결할 수 있는 방법은 클라이언트의 기대에 맞게 상속계층을 분리하는 것임.
100.  펭귄의 예에서는 날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속계층을 분리하면 서로 다른 요구사항을 가진 클라이언트를 만족시킬 수 있을 것임.
101.  또 하나의 방법은 클라이언트에 따라 인터페이스를 분리하는 것임. 인터페이스는 클라이언트가 기대하는 바에 따라 분리되어야 함.
102.  펭귄이 새의 코드를 재사용해야 해야할 때, 상속을 사용하면 펭귄의 퍼블릭 인터페이스에 fly 오퍼레이션이 추가되기 때문에 안되고 합성을 사용하면 fly 오퍼레이션이 직접적으로 추가되는 것은 아니기 때문에 오히려 좋음.
103.  클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있게 됨. 대부분의 경우 인터페이스는 클라이언트의 요구가 바뀜에 따라 변경되므로, 각 클라이언트의 요구가 바뀌더라도 영향의 파급효과를 효과적으로 제어할 수 있게 됨. 이처럼 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 `인터페이스 분리 원칙(ISP)`라고 부름.
104.  현재의 요구사항이 날 수 있는 행동에 관심이 없다면 상속 계층에 FlyingBird를 추가하는 것은 설계를 불필요하게 복잡하게 만듦. 현실을 정확하게 묘사하는 것이 아니라 요구사항을 실용적으로 수용하는 것을 목표로 삼아야 함. 요점은 자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중하라는 것임.
105.  사람들은 상속을 사용하는 두 가지 목적에 특별한 이름을 붙였는데 `서브클래싱`과 `서브타이핑`이 그것임.
106.  서브클래싱은 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가리키며, 구현상속 또는 클래스상속이라고도 부름.
107.  서브타이핑은 타입계층을 구성하기 위해 상속을 사용하는 경우를 가리킴. 서브타이핑을 인터페이스상속이라고 부르기도 함.
108.  추상클래스를 상속한다는 것은 단순한 코드의 재사용을 위한 상속이 아니라 추상 클래스가 정의하고 있는 인터페이스를 상속하겠다는 의미임.
109.  서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 함. 즉, 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행동 호환성을 만족시켜야 함.
110.  다시 말해, 자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 `대체가능성`을 포함함. 행동호환성과 대체가능성은 올바른 상속 관계를 구축하기 위해 따라야 할 지침이라고 할 수 있음.
111.  `리스코프 치환원칙`을 한마디로 정리하면, 서브타입은 그것의 기반타입에 대해 대체 가능해야 한다는 것으로 클라이언트가 차이점을 인식하지 못한 채 기반클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다는 것임.
112.  리스코프 치환원칙은 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다는 아주 중요한 결론을 이끔. 어떤 모델의 유효성은 클라이언트의 관점에서만 검증 가능하다는 것임. 따라서 클라이언트와 인스턴스 간의 협력관계를 파악해야 검증가능함.
113.  행동호환성과 리스코프 치환원칙에서 한 가지만 기억해야 한다면 대체 가능성을 결정하는 것은 클라이언트라는 것임.
114.  is-a 관계로 표현된 문장을 볼 때마다 문장 앞에 `클라이언트의 입장에서`라는 말이 빠져있다고 생각해야 함.

```
1. (클라이언트 입장에서)정사각형은 직사각형이다(X).
2. (클라이언트 입장에서)펭귄은 새다(X).
```

115. 클라이언트를 배제한 is-a 관계는 개발자를 혼란으로 몰아갈 가능성이 높음.
116. is-a 관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조함. 결론적으로 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계임.
117. 한가지 잊지 말아야 할 사실은 클래스 상속은 타입계층을 구현할 수 있는 다양한 방법 중 하나일 뿐이라는 것임. 자바의 interface를 사용하면 클래스 사이의 상속을 사용하지 않고 서브타이핑 관계를 구현할 수 있음. 핵심은 구현 방법과 무관하게 클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용돼야 한다는 것임.
118. 서브타입이 리스코프 치환원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 `계약`을 준수해야 함.
119. 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 `계약에 의한 설계`라고 부름. 계약에 의한 설계는 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 `사전조건`과 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 `사후조건`, 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 `클래스 불변식`의 세가지 요소로 구성됨.
120. 서브타입이 슈퍼타입처럼 보일 수 있으려면 클라이언트가 슈퍼타입과 맺은 계약을 서브타입이 준수해야 함.
121. 서브타입에 더 강력한 사전조건을 정의할 수 없음. 클라이언트는 서브타입의 사전조건을 확인할 수 없어서 슈퍼타입의 사전조건에 맞춰 값을 전달함. 따라서 서브타입의 사전조건이 더 강력하다면 오류가 발생함. 하지만 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수는 있음.
122. 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있지만, 더 약한 사후조건을 정의할 수는 없음.
123. 사전조건은 인자로 들어오는 값에 대해 제한을 두는 것이고 사후조건은 반환값으로 처리되는 값에 대해 제한을 두는 것임.
124. 지금까지 살펴본 것처럼 리스코프 치환원칙을 설명하기 위해 계약에 의한 설계개념을 이용할 수 있음. 또한 계약에 의한 설계는 클라이언트 관점에서의 대체 가능성을 계약으로 설명할 수 있다는 사실을 잘 보여줌.
125. 행동호환성 + 계약에 의한 설계를 준수해야 서브타이핑의 조건을 달성한 것임.
126. 객체지향 설계의 목표는 적절한 책임을 수행하는 객체들의 협력을 기반으로 결합도가 낮고 재사용 가능한 코드 구조를 창조하는 것임. 재사용을 위해서는 객체들의 협력 방식을 일관성있게 만들어야 함. 가능한 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용해야 함.
127. 일관성 있는 협력 패턴을 적용하면 코드가 이해하기 쉽고 직관적이며 유연해짐.
128. FixedFeePolicy, TimeOfDayDiscountPolicy, DayOfWeekDiscountPolicy의 세 클래스를 함께 모아놓고 보면 그 동안 보이지 않던 문제점이 보이기 시작함. 현재 구현의 가장 큰 문제점은 이 클래스들이 유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다는 것임. 이 클래스들은 기본 정책을 구현한다는 공통의 목적을 공유하지만, 정책을 구현하는 방식은 완전히 다름. 다시말해, 개념적으로는 연관돼 있지만 구현 방식에 있어서는 완전히 제각각이라는 것임. 이러한 비일관성은 두가지 상황에서 발목을 잡음. 하나는 새로운 구현을 추가해야 하는 상황이고, 또 다른 하나는 기존의 구현을 이해해야 하는 상황임. 새로운 구현을 추가하면 추가할수록 코드 사이의 일관성은 점점 더 어긋나게 되고, 유사한 요구사항을 구현하는 서로 다른 구조의 코드는 코드를 이해하는데 심리적인 장벽을 만듦.
129. 결론은 유사한 기능을 서로 다른 방식으로 구현해서는 안된다는 것임. 일관성 없는 설계와 마주한 개발자는 여러 가지 해결 방법 중에서 현재의 요구사항을 해결하기에 가장 적절한 방법을 찾아야 하는 부담을 안게 됨. 유사항 기능은 유사한 방식으로 구현해야 함. 객체지향에서 기능을 구현하는 유일한 방법은 객체 사이의 협력을 만드는 것뿐이므로 유지보수 가능한 시스템을 구축하는 첫걸음은 협력을 일관성 있게 만드는 것임.
130. 일관성 있는 설계를 만드는 데 가장 훌륭한 조언은 다양한 설계 경험을 익히라는 것임. 설계 경험이 풍부하면 풍부할수록 어떤 위치에서 일관성을 보장해야 하고 일관성을 제공하기 위해 어떤 방법을 사용해야 하는지를 직관적으로 결정할 수 있음. 두번째 조언은 널리 알려진 디자인 패턴을 학습하고 변경(새로운 클래스 추가)이라는 문맥 안에서 디자인 패턴을 적용해보는 것임. 디자인 패턴은 특정한 변경에 대해 일관성 있는 설계를 만들 수 있는 경험 법칙을 모아놓은 일종의 설계 템플릿임. 디자인 패턴을 학습하면 빠른 시간 안에 전문가의 경험을 흡수할 수 있음.
131. 비록 디자인 패턴이 반복적으로 적용할 수 있는 설계 구조를 제공한다고 하더라도 모든 경우에 적합한 패턴을 찾을 수 있는 것이 아님. 따라서 협력을 일관성 있게 만들기 위해 다음과 같은 기본 지침을 따르는 것이 좋음.

```
1. 변하는 개념을 변하지 않는 개념으로부터 분리해라.
2. 변하는 개념을 캡슐화해라.
```

132. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킴. 이것이 여러 설계 원칙 중에서 첫번째 원칙임. 즉, 코드에서 새로운 요구사항이 있을 때마다 바뀌는 부분이 있다면 그 행동을 바뀌지 않는 다른 부분으로부터 골라내서 분리해야 한다는 것을 알 수 있음.
133. 절차지향 프로그램에서 변경을 처리하는 전통적인 방법은 조건문의 분기를 추가하거나 개별 분기 로직을 수정하는 것임. 객체지향에서는 적합하지 않은 방법임. 클라이언트인 Movie는 서버인 할인 정책이 어떤 종류인지 판단하지 않음. 단지 참조를 통해 메시지를 전달할 뿐임. 객체지향적인 코드는 조건을 판단하지 않고 단지 다음 객체로 메시지를 전달함.
134. 기존 조건 로직을 객체 사이의 이동으로 대체하기 위해서는 커다란 클래스를 더 작은 클래스들로 분리해야 함. 클래스를 분리하기 위한 가장 중요한 기준은 변경의 이유와 주기임. 클래스는 명확히 단 하나의 이유에 의해서만 변경돼야 하고, 클래스 안의 모든 코드는 함께 변경돼야 함.
135. 변하는 개념을 캡슐화하기 위한 핵심은 훌륭한 추상화를 찾아 추상화에 의존하게 만드는 것임.
136. 많은 사람들은 객체의 캡슐화에 관한 이야기를 들으면 반사적으로 데이터 은닉을 떠올림. 그러나 캡슐화는 데이터 은닉 이상으로 변하는 어떤 것이든 감추는 것임. 캡슐화의 가장 대표적인 예는 객체의 퍼블릭 인터페이스와 구현을 분리하는 것임. 퍼블릭 인터페이스의 뒤로 변하는 전체 부분인 구현이 숨겨지게 됨.
137. 객체 캡슐화란 객체와 객체 사이의 관계를 캡슐화함. 인스턴스 변수로써 퍼블릭 인터페이스를 private로 가지고 있으면, 두 객체 사이의 관계를 변경하더라도 외부에는 영향을 미치지 않음. 객체 캡슐화는 합성을 의미함.
138. 서브타입 캡슐화는 다형성을 의미함.
139. 일반적으로 데이터 캡슐화와 메서드 캡슐화는 개별 객체에 대한 변경을 관리하기 위해 사용하고, 객체 캡슐화와 서브타입 캡슐화는 협력에 참여하는 객체들의 관계에 대한 변경을 관리하기 위해 사용함.
140. 서브타입 캡슐화와 객체 캡슐화를 적용하는 방법은 변하는 부분을 분리해서 타입 계층을 만들고, 변하지 않는 부분의 일부로 타입 계층을 합성하는 것임.
141. 변하는 부분을 변하지 않는 부분으로부터 분리했기 때문에 변하지 않는 부분을 재사용할 수 있음. 그리고 새로운 기능을 추가하기 위해 오직 변하는 부분만 구현하면 되기 때문에 원하는 기능을 쉽게 완성할 수 있음. 변경 전의 설계는 전체적으로 일관성이 떨어지기 때문에 코드에 대해 가지고 있던 기존의 지식이 유사한 기능을 이해하는 데 아무런 도움이 되지 않았음. 일단 일관성 있는 협력을 이해하고 나면 변하는 부분만 따로 떼어내어 독립적으로 이해하더라도 전체적인 구조를 쉽게 이해할 수 있음. 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 `개념적 무결성`을 유지할 수 있는 가장 효과적인 방법임. 개념적 무결성을 일관성과 동일한 뜻으로 간주해도 무방함. 시스템이 일관성있는 몇 개의 협력 패턴으로 구성된다면 시스템을 이해하고, 수정하고, 확장하는 데 필요한 노력과 시간을 아낄 수 있음.
142. 기존의 협력방식에서 벗어날 수밖에 없을 때, 또 다른 협력 패턴을 적용하는 것이 최선의 선택이 아님. 가급적 기존의 협력 패턴에 맞추는 것이 가장 좋은 방법임. 비록 설계를 약간 비트는 것이 조금은 이상한 구조를 낳더라도 전체적인 일관성을 유지할 수 있는 설계를 선택하는 것이 현명함.
143. 애플리케이션에서 유사한 기능에 대한 변경이 지속적으로 발생하고 있다면 변경을 캡슐화할 수 있는 적절한 추상화를 찾은 후, 이 추상화에 변하지 않는 공통적인 책임을 할당해야 함. 현재의 구조가 변경을 캡슐화하기에 적합하지 않다면 코드를 수정하지 않고도 원하는 변경을 수용할 수 있도록 협력과 코드를 리팩토링해야 함. 변경을 수용할 수 있는 적절한 역할과 책임을 찾다 보면 협력의 일관성이 서서히 윤곽을 드러낼 것임. 객체지향 설계는 객체의 행동과 그것을 지원하기 위한 구조를 계속 수정해 나가는 작업을 반복해 나가면서 다듬어짐. 객체, 역할, 책임은 계속 진화해나가는 것임.
144. 애플리케이션을 설계하다 보면 어떤 요구사항을 해결하기 위해 과거에 경험했던 유사한 해결 방법을 다시 사용하는 경우가 있음. 이처럼 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 `디자인 패턴`이라고 부름. 디자인 패턴의 목적은 설계를 재사용하는 것임. 디자인 패턴은 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음임. 일단 디자인 패턴을 익히고 나면 변경의 방향과 주기를 이해하는 것만으로도 필요한 역할과 책임, 역할들의 협력 방식을 순간적으로 떠올릴 수 있게 됨.
145. 디자인 패턴이 설계를 재사용하기 위한 것이라면 `프레임워크`는 설계와 코드를 함께 재사용하기 위한 것임. 프레임워크는 애플리케이션의 아키텍쳐를 구현 코드의 형태로 제공함.
146. 디자인 패턴과 프레임워크 모두 일관성 있는 협력과 관련있음. 디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공하고 프레임워크는 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공함. 결론적으로 디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법임.
147. 개인적으로 가장 선호되는 패턴의 정의는 마틴 파울러의 하나의 실무 컨텍스트에서 유용하게 사용해 왔고 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어라는 것임. 아이디어라는 용어를 사용하는 이유는 어떤 것도 패턴이 될 수 있기 때문임.
148. 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점임. 패턴은 경험의 산물임. 따라서 실무 경험이 적은 초보자라고 하더라도 패턴을 익히고 반복적으로 적용하는 과정 속에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 됨.
149. 마틴 파울러가 언급한 것처럼 패턴의 범위가 소프트웨어 개발과 직접적으로 연관성을 가진 분석, 설계, 구현 영역만으로 한정되는 것은 아님. 다양한 크기의 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법, 스토리 카드나 백로그를 통해 요구사항을 관리하는 방법과 같이 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이 될 수 있음.
150. 패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 아키텍처 패턴, 분석 패턴, 디자인 패턴, 이디엄의 4가지로 분류하는 것임. 4가지 중에서 가장 널리 알려진 것은 디자인 패턴으로, 디자인 패턴은 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트 사이에서 반복적으로 발생하는 구조를 서술함. 디자인 패턴은 중간 규모의 패턴으로, 특정한 설계 문제를 해결하는 것을 목적으로 함. 디자인 패턴의 상위에는 소프트웨어의 전체적인 구조를 결정하기 위해 사용할 수 있는 아키텍처 패턴이 위치함. 디자인 패턴의 하위에는 이디엄이 위치함. 이디엄은 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로, 주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술함. 예를 들어 자바의 가비지 컬렉션 메커니즘이 있음. 아키텍처 패턴, 디자인 패턴, 이디엄이 주로 기술적인 문제를 해결하는 데 초점을 맞추고 있다면 분석 패턴은 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춤.
151. 패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공함.
152. STRATEGY 패턴은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공함. BRIDGE 패턴은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만듦. OBSERVER 패턴은 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공함.
153. 여기서 언급한 패턴들의 세부적인 내용이 중요한 것이 아님. 중요한 것은 패턴을 따르면 특정한 상황에 적응할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실임.
154. 패턴의 구성 요소는 클래스가 아니라 역할임. 예를 들어 COMPOSITE 패턴의 구성 요소인 Component, Composite, Leaf는 클래스가 아니라 협력에 참여하는 객체들의 역할임. Component는 역할이기 때문에 Component가 제공하는 오퍼레이션을 구현하는 어떤 객체라도 Component의 역할을 수행할 수 있음. 패턴을 구성하는 요소가 클래스가 아니라 역할이라는 사실은 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 사실을 암시함.
155. 디자인 패턴의 구성요소가 클래스와 메서드가 아니라 역할과 책임이라는 사실을 이해하는 것이 중요함. 어떤 구현 코드가 어떤 디자인 패턴을 따른다고 이야기할 때는 역할, 책임, 협력의 관점에서 유사성을 공유한다는 것이지 특정한 구현 방식을 강제하는 것은 아니라는 점을 이해하는 것이 중요함.
156. 몇 가지 이례적인 경우를 제외하면 널리 알려진 대부분의 디자인 패턴은 협력을 일관성 있고 유연하게 만드는 것을 목적으로 함. 따라서 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의함.
157. 메서드의 구현을 캡슐화하기 위해 합성을 사용하던 방식이 STRATEGY 패턴을 적용한 예임. STRATEGY 패턴의 목적은 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용함. 여기서 합성 대신 상속관계를 사용하는 것은 TEMPLATE METHOD 패턴이라고 부름. 부모클래스의 특정 메서드는 이미 구현되어 있으나, 자식이 오버라이딩 해야하는 추상메서드를 포함하여 자식이 오버라이딩시, 부모의 구현된 메서드가 변화하는 방식이 TEMPLATE METHOD 패턴의 전형적인 구현 방법임. 이처럼 TEMPLATE METHOD 패턴은 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화할 수 있는 디자인 패턴임. 다만 합성보다는 결합도가 높은 상속을 사용했기 때문에 STRATEGY 패턴처럼 런타임에 객체의 알고리즘을 변경하는 것은 불가능함.
158. DECORATOR 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로써 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용함. DECORATOR 패턴은 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화할 수 있음.
159. 디자인 패턴에서 중요한 것은 디자인 패턴의 구현 방법이나 구조가 아님. 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요함. 그리고 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를 이해하는 것이 더 중요함. 즉, 변경의 종류마다 적용하는 디자인 패턴이 다름.
160. 패턴은 설계의 목표가 돼서는 안됨. 패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과함. 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정해야 함.
161. 패턴을 사용하면서 부딪히게 되는 대부분의 문제는 패턴을 맹목적으로 사용할 때 발생함. 대부분의 패턴 입문자가 빠지기 쉬운 함정은 패턴을 적용하는 컨텍스트의 적절성은 무시한 채 패턴의 구조에만 초점을 맞추는 것임. 이를 패턴 만능주의라고 부름. 패턴을 남용하지 않기 위해서는 다양한 트레이드오프 관계 속에서 패턴을 적용하고 사용해 본 경험이 필요함.
162. 전문가와 초심자의 차이점은 전문가는 다양한 실무 경험을 통해 어떤 컨텍스트에서 어떤 패턴을 적용해야 하는지, 그리고 이보다 더 중요한 것으로 어떤 패턴을 적용해서는 안되는지에 대한 감각을 익히고 있다는 점임. 패턴에 처음 입문한 사람들은 패턴의 강력함에 매료된 나머지 아무리 사소한 설계라도 패턴을 적용해보려고 시도함. 그러나 명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해지게 됨. 따라서 굳이 패턴을 사용하지 않아도 될 때를 잘 판단해내야 함. 정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물임. 패턴을 적용할 때는 함께 작업하는 사람들이 패턴에 익숙한지 여부를 확인하고, 그렇지 않다면 설계에 대한 지식과 더불어 패턴에 대한 지식도 함께 공유하는 것이 필요함.
163. 패턴에 맞추기 위해 리팩터링하는 과정이 패턴이 적용된 최종결과를 이해하는 것보다 효과적일 수도 있음.
164. 문제를 분석하고 창의력을 발휘함으로써 패턴을 현재의 문제에 적합하도록 적절하게 수정해야 함.
165. 다양한 도메인에서 재사용이 가능한 구현부는 비현실적임. 하지만 추상적인 부분의 설계를 재사용하여 반복되는 코드의 재사용을 피할 수는 있음. 프레임워크란 추상클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계 또는 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격을 의미함.
166. 프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용함. 프레임워크는 애플리케이션의 아키텍쳐를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함함. 이미 추상클래스나 인터페이스들이 정의되어 있기 때문에 아키텍쳐를 제공한다고 봐도 되는 것임. 비록 프레임워크가 즉시 업무에 투입할 수 있는 구체적인 서브클래스를 포함하고 있기는 하지만 프레임워크는 코드의 재사용보다는 설계 자체의 재사용을 중요시함.
167. 프레임워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 배포 단위로 분리해야 함. 상위 정책 패키지와 하위 정책 패키지를 물리적으로 완전히 분리하고 나면 상위 정책 패키지를 여러 애플리케이션에서 재사용할 수 있는 기반이 마련된 것임. 동일한 프레임워크를 사용하는 여러 애플리케이션에 걸쳐 일관성 있게 코드를 설계하고 구현할 수 있음. 또한 동일한 프레임워크를 사용하는 애플리케이션은 구현 방식에 일관성이 있기 때문에 이해하기도 쉬움. 추가적으로 설계와 함께 코드 역시 재사용할 수 있음.
168. 의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘임. 의존성 역전은 의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전시킴. 의존성을 역전시킨 객체지향 구조에서는 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출함. 따라서 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동함. 즉, 의존성을 역전시키면 제어 흐름의 주체 역시 역전됨. 이를 `제어 역전 원리` 또는 `할리우드 원리`라고 함. 상위모듈이 하위모듈을 의존성으로써 가지기 때문에 제어흐름 또한 상위모듈이 가지게 되는 것을 말함. 애플리케이션의 전체적인 협력 흐름은 프레임워크에 정의되어 있음. 또한 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둠. 이렇게 완성되지 않은 채로 남겨진 동작을 `훅`이라고 부름. 재정의된 훅은 제어 역전 원리에 따라 프레임워크가 원하는 시점에 호출됨. 제어란 원하는 시점에 특정 컨텍스트를 호출할 수 있는 능력을 말함. 여기서 협력을 제어하는 것은 프레임워크라는 것에 주목해야 함. 우리는 프레임워크가 적절한 시점에 실행할 것으로 예상되는 코드를 작성할 뿐임. 제어가 우리에게서 프레임워크로 넘어간 것임. 내가 구현한 코드는 주도권이 없고 프레임워크가 해당 코드의 주도권을 가져감. 개발자는 이미 특정 이름과 호출 방식이 결정된 오퍼레이션을 작성해야 하지만 결정해야 하는 설계 개념은 줄어들고 애플리케이션별로 구체적인 오퍼레이션의 구현만 남게 됨. 이러한 제어의 역전이 프레임워크의 핵심 개념인 동시에 코드의 재사용을 가능하게 하는 힘이라는 사실을 이해해야 함.
169. 스프링 프레임워크에서는 사용자가 bean에 해당하는 코드를 직접 구현해야 하지만, 결국 주도권은 스프링 프레임워크가 가지기 때문에 런타임 시 bean주입을 해줌. 프레임워크가 직접 컨트롤할 수 있게 해줘야 협력의 통일성이 이뤄질 수 있는 것임. 프레임워크의 사용이유는 결국 IOC를 통해 협력의 통일성을 유도하고 구현의 책임만 사용자가 갖기 위해서임.
170. 앨리스터 코어번은 사람들이 새로운 기술을 학습하기 위해서 이뤄지는 세가지 단계를 따라하는 수준, 분리 수준, 거침없는 수준이라고 부름. 어떤 기술을 처음 학습하려는 사람은 따라하는 수준에서 시작함. 분리 수준의 사람들은 오직 단 하나의 절차만으로는 모든 문제를 해결할 수 없다는 사실을 깨닫고 다양한 절차를 학습하고 트레이드오프함. 이러한 학습자들은 모든 경우에 올바른 절차란 존재하지 않는다는 사실을 이해하고 각 상황에 따라 적절한 절차를 적용할 수 있는 판단력과 유연함을 익힘. 거침없는 수준에 이른 사람은 많은 학습과 경험을 통해 즉시 절절한 해법을 직관적으로 떠올릴 수 있을뿐만 아니라 때로는 자신만의 방법에 따라 문제를 해결하기도 함. 이책은 따라하는 수준이라고 가정하고 가장 이상적인 절차와 방법을 통해 객체지향 설계를 설명했음. 따라서 이 책에서 설명하는 원칙과 기법들을 우리의 실무에 적용하기 위해서는 다양한 상황을 트레이드오프할 수 있는 능력을 길러야 함. 따라하는 수준에서 벗어나 분리 단계로 나아가는 것임. 따라하는 수준에 머물러 있다면 이 책에서 다루는 다양한 원칙과 기법들을 적용하기가 생각보다 쉽지 않다는 사실을 알 수 있음. 따라서 디자인 패턴, 리팩터링, 테스트주도개발과 같은 다양한 설계 기법들을 익히고 통찰력을 길러 분리 수준을 향해 나아가는 게 좋음. 위의 활용법들을 추가적으로 익히고 실제 프로젝트를 진행하면서 매번 트레이드오프를 연습하는 과정이 필요한 것임.
171. 인터페이스만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어려움. 계약에 의한 설계를 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화할 수 있음. 계약에 의한 설계 코드를 구현하는 방법보다 계약에 의한 설계를 사용하는 이유와 장점을 이해하는 것이 중요함.
172. 메시지의 이름과 파라미터 목록은 시그니처를 통해 전달할 수 있지만 협력을 위해 필요한 약속과 제약은 인터페이스를 통해 전달할 수 없기 때문에 협력과 관련된 상당한 내용이 암시적인 상태로 남게 됨. 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 것임. 협력에 참여하는 각 객체는 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 이행함. 협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스 상에 문서화됨. 즉, 계약에 의한 설계 개념은 '인터페이스에 대해 프로그래밍하라'는 원칙을 확장한 것임. 우리는 메서드의 이름과 매개변수의 이름을 통해 오퍼레이션이 클라이언트에게 어떤 것을 제공하려고 하는지를 충분히 설명할 수 있음. 6장에서 설명한 의도를 드러내는 인터페이스를 만들면 오퍼레이션의 시그니처만으로도 어느 정도까지는 클라이언트와 서버가 협력을 위해 수행해야 하는 제약조건을 명시할 수 있음. 계약은 여기서 한걸음 더 나아감. reserve 메서드를 호출할 때 클라이언트 개발자는 customer의 값에 null을 전달할 수 있고 audienceCount의 값으로 음수를 포함한 어떤 정수도 전달할 수 있다고 가정할지도 모름. 협력하는 클라이언트는 정상적인 상태를 가진 객체와 협력해야 함.
173. 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것이라고 기대함. 클라이언트는 자신이 원하는 값을 서버가 반환할 것이라고 예상함. 클라이언트는 메시지 전송 전과 후의 서버의 상태가 정상적일 것이라고 기대함. 이 세가지 기대가 바로 계약에 의한 설계를 구성하는 세가지 요소에 대응됨. 이 요소들을 순서대로 `사전조건`, `사후조건`, `불변식`이라고 부름.
174. 계약에 의한 설계의 핵심은 클라이언트와 서버 사이의 견고한 협력을 위해 준수해야 하는 규약을 정의하는 것임.
175. 자바에서는 assert문을 통해 계약에 의한 설계를 적용할 수 있음.
176. protected 인스턴스 변수를 가진 부모클래스의 불변성은 자식 클래스에 의해 언제라도 쉽게 무너질 수 있음. 모든 인스턴스 변수의 가시성이 private로 제한되어야 하는 이유가 이것임.
177. 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안됨. 또한 서브타입의 리턴 타입은 공변성을 가져야 함. 우리가 흔히 이야기하는 리스코프 치환 원칙은 공변성과 관련된 원칙이라고 생각하면 됨. 지금까지 살펴본 서브타이핑은 단순히 서브타입이 슈퍼타입의 모든 위치에서 대체 가능하다는 것임. 하지만 공변성과 반공변성의 영역으로 들어서기 위해서는 타입의 관계가 아니라 메서드의 리턴타입과 파라미터 타입에 초점을 맞춰야 함. 오버라이딩한 메서드의 반환값을 원래 반환타입의 서브타입으로 변경해도 클라이언트가 사용할 때 문제될 것이 없음. 이처럼 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 부모클래스에서 선언한 반환타입의 서브타입으로 지정할 수 있는 특성을 `리턴 타입 공변성`이라고 함. 슈퍼타입 대신 서브타입을 반환하는 것은 더 강력한 사후조건을 정의하는 것과 같음.
178. 서브타입의 메서드 파라미터는 반공변성을 가져야 하지만, 현재 자바 언어에서는 파라미터 반공변성을 허용하지 않음. 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 수 있는 특성을 `파라미터 타입 반공변성`이라고 부름.
179. 많은 사람들이 갖고 있는 흔한 오해는 타입과 클래스가 동일한 개념이라는 것임. 타입은 개념의 분류를 의미하고 클래스는 타입을 구현하는 한가지 방법일 뿐임. 타입의 개념을 이해하는 데 가장 큰 걸림돌은 타입을 구현하는 방법이 다양하다는 점임.
180. 상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약도 해결할 수 있는 방법은 클래스가 아닌 인터페이스를 사용하는 것임. 인터페이스가 다른 인터페이스를 확장하도록 만들면 슈퍼타입과 서브타입 간의 타입계층을 구성할 수 있음.
181. 클래스가 아니라 타입에 집중해야 함. 중요한 것은 객체가 외부에 제공하는 행동, 즉 타입을 중심으로 객체들의 계층을 설계하는 것임.
182. 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피하는 방법은 추상클래스를 이용하는 방법임. 부모 추상클래스의 구현에 대해 자식클래스는 알필요가 없으므로 결합도가 낮음.
183. 한가지 조언은 모든 구체클래스의 부모클래스를 항상 추상클래스로 만들기 위해 노력하라는 것임. 의존하는 대상이 더 추상적일수록 결합도는 낮아지고 결합도가 낮아질수록 변경으로 인한 영향도도 줄어듦. 또한 추상클래스의 특성상 처음부터 상속을 염두에 두고 설계된 클래스라는 점에서 상속을 염두에 두고 설계된 것이 아닌 일반클래스와 달리 결합도로 인한 부작용을 방지할 수 있는 안전망을 제공함.
184. 인터페이스만을 사용하는 방법의 단점인 구현 코드를 포함시킬 수 없어 인터페이스만으로는 중복 코드를 제거하기 어렵다는 점을 해결하기 위해 인터페이스를 이용해 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유할 필요가 있을 경우에는 추상클래스를 이용해 코드 중복을 방지하는 방법이 있음. 이런 형태로 추상클래스를 사용하는 방식을 `골격 구현 추상클래스`라고 부름. 인터페이스와 추상클래스의 혼합 사용법임. 가장 좋은 방법이 인터페이스와 추상 클래스를 결합하는 것임. 다양한 구현 방법이 필요한 경우, 추상클래스가 구현체이므로 새로 하나를 추가하면 되고 이미 부모(추상)클래스가 존재하는 클래스라 하더라도 인터페이스를 추가함으로써 새로운 타입으로 쉽게 확장할 수 있음.
185. 원하는 설계가 상속계층에 얽매이지 않는 타입계층을 요구한다면 인터페이스로 타입을 정의하고 추상클래스로 기본 구현을 제공해서 중복코드를 제거해야 함. 하지만 이런 복잡성이 필요하지 않다면 타입을 정의하기 위해 인터페이스나 추상클래스 둘 중 하나만 사용하는 게 좋음.
186. 인터페이스의 디폴트 메서드를 사용하면 골격 구현 추상클래스를 만들지 않아도 될 것 같지만, 인터페이스가 가져야 하는 인스턴스 변수 및 오퍼레이션이 추가돼야 하는 등 문제점이 생기게 됨. 또한 이렇게 추가된 오퍼레이션들은 디폴트 메서드 안에서 사용된다는 이유만으로 public 메서드가 되어야 해서 외부에 노출할 필요가 없는 메서드를 불필요하게 퍼블릭 인터페이스에 추가하는 결과를 낳게 됨(public 메서드 내에서는 public 메서드만 사용 가능한가?).
187. 이것은 자바8에 디폴트 메서드가 추가된 이유가 인터페이스로 추상 클래스의 역할을 대체하려는 것이 아니기 때문임. 디폴트 메서드가 추가된 이유는 기존에 널리 사용되고 있는 인터페이스에 새로운 오퍼레이션을 추가할 경우에 발생하는 오버라이딩 문제를 해결하기 위해서지 추상클래스를 제거하기 위해서가 아님.
188. 여기서 사용된 방법들을 사용해 타입계층을 구현한다고 하더라도 리스코프 치환원칙을 준수하지 않는다면 올바른 타입계층을 구현한 것이 아님.
189. 대부분의 사람들은 코드로 표현되는 정적모델(클래스)가 동적모델(객체)보다 중요할 것이라고 생각할 것임. 하지만 정적 모델은 동적 모델에 의해 주도돼야 하고 동적 모델이라는 토대위에 세워져야 함. 동적 모델을 기반으로 정적 모델을 구상할 때 고려해야 하는 중요한 요소는 변경임. 정적 모델을 설계하는 이유는 단지 행동과 변경을 적절하게 수용할 수 있는 코드 구조를 찾는 것이어야 함. 동일한 행동을 제공하는 정적 모델이 있다면 항상 현재의 설계에서 요구되는 변경을 부드럽게 수용할 수 있는 설계를 선택해야 함.
190. 도메인 안의 개념이 제공하는 틀에 맞춰서 소프트웨어를 구축해야 한다고 생각하면 안됨. 객체들의 협력관계 설계가 도메인 개념의 틀보다 우선순위가 되어야 함. 우리에게 중요한 것은 소프트웨어의 기능과 객체의 책임임. 코드의 구조를 이끄는 것은 도메인 안에 정립된 개념의 분류 체계가 아니라 객체들의 협력임. 도메인 안의 개념들을 기반으로 출발하되 객체들의 협력이 도메인 모델에 맞지 않다면 필요한 몇가지 개념만 남기고 도메인 모델을 과감히 수정해야 함.
191. Monster 클래스 예제를 통해 새로운 몬스터가 필요할 때마다 새로운 클래스를 추가하지 않고, 내부에 Breed 인터페이스를 합성하는 것을 통해 새로운 클래스를 추가하지 않고 여러 종류의 몬스터들을 구현할수 있음을 알 수 있었음. 이것은 상속 대신 합성을 사용하라는 설계 지침을 따르는 또 다른 예시임. 이 경우 타입은 인터페이스나 클래스로 구현되지 않고, 클래스의 인스턴스로 구현됨. 다시 말해 어떤 객체의 타입을 표현하는 별도의 객체를 이용해 타입을 구현하는 것임. 이처럼 어떤 인스턴스가 다른 인스턴스의 타입을 표현하는 방법을 TYPE OBJECT 패턴이라고 부름. 지금 살펴본 방법은 타입을 구현할 수 있는 또 다른 방법인 것임.
192. 도메인 모델은 단순히 클래스 다이어그램이 아님. 도메인의 핵심을 간략하게 단순화해서 표현할 수 있는 모든 것이 도메인 모델임. 그리고 그렇게 작성된 개념이 우리의 코드에 대한 구조와 행동을 드러낸다면 그것은 더없이 훌륭한 도메인 모델임. 형식은 중요하지 않고 중요한 것은 전달하려는 의미임. 또한 도메인 모델이 단순히 정적 모델의 형태를 띌 필요가 없으며 도메인 모델의 구조가 코드와 다를 필요가 없음. 중요한 것은 도메인 모델을 봤을 때 도메인의 개념뿐만 아니라 코드도 함께 이해될 수 있는 구조를 찾는 것임.

### 코딩

1. 일반배열을 ArrayList같은 List에 추가하기 위해서는 Arrays.asList()를 통해 List로 변경해준 뒤, addAll()을 사용해야 함.
2. List의 remove()는 제거와 동시에 값을 반환해줌.
