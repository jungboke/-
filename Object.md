## 오브젝트

### 중요 개념

0. 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것임.
1. 설계를 어렵게 만드는 것은 의존성이며, 불필요한 의존성을 제거함으로써 해당 문제를 해결할 수 있음.
2. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것임.
3. 훌륭한 설계는 적절한 트레이드오프(ex 자율성vs결합도)의 결과물임.
4. 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계원칙임. 이를 인터페이스와 구현의 분리 원칙이라고 함.
5. 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리해야 클라이언트는 클래스를 사용하며 알아야 하는 지식을 줄일 수 있고, 작성자는 파급효과 걱정을 하지 않고, 내부 구현을 마음대로 변경할 수 있음.
6. 객체의 데이터(인스턴스 변수)를 처리하는 메서드는 언제나 해당 객체가 가지고 있는 게 좋음. 이러면 응집도가 증가함.
7. 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이 핵심임. 클라이언트는 메시지 수신 객체가 메시지에 응답할 수 있다는 것만 알면 됨. 메시지에 응답할 수 있다는 것은 인터페이스를 통해 확인하는 것임.
8. 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킴.
9. 코드 수정을 회피하려는 이유는 두려움이며, 두려움은 변경으로 인해 버그가 생길지 모른다는 불확실성에서 기인함. 따라서 우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드임.
10. 대부분의 사람들은 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 고민함. 이것은 객체지향의 본질과는 거리가 멀고, 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있음. 이를 위해 두가지에 집중해야 함.

```
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라.
```

10. 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 함. 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현해야 함.
11. 외부에서는 객체의 속성에 직접 접근할 수 없도록 막고 적절한 public 메서드를 통해서만 내부 상태를 변경할 수 있게 해야 함.
12. 클래스의 내부와 외부를 구분해야 하는 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문임. 그리고 해당 객체를 사용하는 클라이언트는 상세정보를 알 필요 없어서 좋고, 개발자는 구현부를 유출하지 않아서 구현의 자유를 얻음.
13. 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 점임. 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현해야 함(ex Money vs Long). 그 개념이 비록 하나의 인스턴스 변수만 포함하더라도, 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음임.
14. 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 좋지 않은 선택임. 항상 예외케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택해야 함(ex NoneDiscountPolicy).
15. NoneDiscountPolicy라는 새로운 클래스를 추가하는 것만으로 애플리케이션의 기능이 확장된 것처럼, 추상화를 중심으로 코드의 구조를 설계하면, 유연하고 확장 가능한 설계를 만들 수 있음.
16. 추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는 것을 방지하기 때문임.
17. 유연성이 필요한 곳에 추상화를 사용하라.
18. 코드 재사용을 위해서는 상속보다 합성이 더 좋음. `합성`은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말함.
19. 상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이지만, 두 가지 관점에서 설계에 안좋은 영향을 끼침.

```
1. 상속은 캡슐화를 위반함(부모 클래스의 내부 구조를 잘 알아야 함).
2. 상속은 설계를 유연하지 못하게 만듦(실행 시점에 객체의 종류 변경 불가능함).
```

20. 합성은 위의 두 문제를 모두 해결하는데, 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하므로, 구현을 효과적으로 캡슐화할 수 있음. 또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만듦.
21. 그렇다고 상속을 절대 사용하지 말라는 뜻이 아닌데, 대부분의 설계에서는 상속과 합성을 함께 사용해야 함.
22. 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것임.
23. 객체지향 패러다임의 관점에서 핵심은 역할, 책임, 협력임.
24. 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현(클래스,상속)에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 됨.
25. 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것임.
26. 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력임. 객체의 상태를 결정하는 것은 객체의 행동임.
27. 따라서 협력은 객체를 설계하는 데 필요한 일종의 `문맥`을 제공함.
28. 객체가 협력에서 어떠한 책임(or 역할)을 맡는지 판단하는 게 해당 객체 설계의 첫단계임.
29. 객체의 책임은 객체가 `무엇을 알고 있는가`와 `무엇을 할 수 있는가`로 구성됨. 예를 들어 Screening은 영화를 예매할 수 있어야 하며, 자신이 상영할 영화(의존성 객체)를 알고 있어야 함.
30. 책임과 메시지의 크기는 다른데, 책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로 더 큼. 하나의 객체가 수행할 수 있다고 생각했던 책임이 나중에는 여러 객체들이 협력해야만 하는 커다란 책임으로 자라는 것이 일반적임.
31. 협력이 중요한 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문임. 객체지향 설계에서 가장 중요한 것은 책임이고, 객체에게 얼마나 적절한 책임을 할당했느냐가 설계의 전체적인 품질을 결정함. 객체의 구현 방법은 상대적으로 책임보다는 덜 중요하며, 책임을 결정한 다음에 고민해도 늦지 않음.
32. CRC카드에서 CRC는 후보-책임-협력을 가리키며, 후보는 클래스,객체,컴포넌트,역할 어떤 것이라도 될 수 있음. CRC카드는 역할을 식별하고, 책임을 할당하며, 협력을 명시적으로 표현하는 구체적이면서도 실용적인 설계 기법임. 협력과 책임을 설계할 때, CRC카드를 사용하면 좋을 듯함.
33. 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것임. 이를 책임 할당을 위한 `정보 전문가 패턴`이라고 부름.
34. 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 보는 것임. 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰나감. 즉, 최초의 책임을 시스템(애플리케이션)이 제공하는 기능으로 두는 것임.
35. 협력을 위한 메시지 설계가 우선이고, 해당 메시지를 처리할 객체를 선택하는 것이 그 뒤임.
36. 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어짐. 그리고 이런 메시지가 메시지를 수신할 객체의 책임을 결정함.
37. 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성함. 협력을 설계하면서 객체의 책임을 식별해 나가는 과정에서 최종적으로 얻게 되는 결과물은 시스템을 구성하는 객체들의 인터페이스와 오퍼레이션의 목록임.
38. 어떤 경우에는 응집도와 결합도의 관점에서 정보 전문가가 아닌 다른 객체에게 책임을 할당하는 것이 더 적절한 경우도 있음. 하지만 기본적인 전략은 책임을 수행할 정보 전문가를 찾는 것임. 정보 전문가에게 책임을 할당하는 것만으로도 상태와 행동을 함께 가지는 자율적인 객체를 만들 가능성이 높아지기 때문임.
39. 이처럼 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 `책임 주도 설계`라고 부름.
40. 다음은 책임 주도 설계 방법의 과정을 정리한 것임.

```
1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악함.
2. 시스템 책임을 더 작은 책임으로 분할함.
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당함.
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾음.
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 됨.
```

41. 책임 주도 설계는 자연스럽게 객체의 구현이 아닌 책임에 집중할 수 있도록 해줌.
42. 책임을 할당할 때 고려해야 하는 두 가지 요소로, 하나는 메시지가 객체를 결정해야 한다는 것이고, 다른 하나는 행동이 상태를 결정한다는 것임.
43. 메시지가 객체를 선택하게 해야 하는 두 가지 중요한 이유가 있음.

```
1. 객체가 최소한의 인터페이스를 가질 수 있게 됨.
2. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 됨.
```

44. 객체가 협력에 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동임. 객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것임. 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정하는 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해함. 객체의 내부 구현을 변경하면, 퍼블릭 인터페이스도 함께 변경되게 됨. 이런 식으로 객체의 내부 구현에 초점을 맞춘 설계 방법을 `데이터 주도 설계`라고 부름.
45. 개별 객체의 상태와 행동이 아닌 시스템의 기능을 구현하기 위한 협력에 초점을 맞춰야만 응집도가 높고 결합도가 낮은 객체들을 창조 할 수 있음.
46. 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 `역할`이라고 부름. 실제로 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는 게 좋음.
47. 역할은 단순하게 객체을 추상화하여 같은 책임을 수행하는 여러 객체들을 담을 수 있는 슬롯으로 생각해도 됨.
48. 메시지 발신 -> 역할 찾기 -> 역할수행 객체 선택 으로 진행됨.
49. 역할에 맞는 객체가 하나뿐이라면, 역할=객체 라고 생각해도 됨.
50. 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있음.
51. 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장에 용이한 유연한 설계로 나아가는 첫걸음임.
52. 인터페이스 업캐스팅, 다형성, 동적바인딩, 상속 등과 같은 기술적 메커니즘들이 모여 유연하고 재사용 가능한 협력을 만들 수 있는 기반을 제공함.
53. 명확한 기준을 세우기 어렵고 정보가 부족한 설계 초반에는 어떤 것이 역할이고, 객체인지 결정을 내리기가 어려울 것임. 또한 도메인 모델 안에는 개념과 객체와 역할이 어지럽게 뒤섞여 있으며, 이것은 사람들이 세계를 바라보는 일반적인 관점임. 이에 대해서 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야 하고, 역할과 객체를 명확하게 구분하는 것은 그리 중요하지 않음. 따라서 애매하다면 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할(추상화)를 분리해내는 것이 가장 좋은 방법임.
54. 설계 초반에 다루는 대부분의 대상은 CRC카드를 설명할 때 언급했던 후보로 취급하는 게 합리적임. 후보는 객체, 역할, 클래스가 될 수 있으며 정확하게 무엇인지 설계 초반에는 그다지 중요하지 않고, 이 시점에서 중요한 것은 협력을 위해 어떤 책임이 필요한지를 이해하는 것임.
55. 다양한 객체들이 협력에 참여한다는 것이 확실하면 역할로 시작하고, 정확한 결정을 내리기 어려운 상황이라면 구체적인 객체로 시작하는 게 좋음.
56. 협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용 가능해짐.
57. 객체지향 커뮤니티에서 오랜 기간 동안 좋은 설계의 특징을 판단할 수 있는 기준에 관해 논의했는데 캡슐화, 응집도, 결합도를 주로 사용함.
58. 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공해주기 때문임. 객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있음. 변경될 가능성이 높은 부분은 구현이라고 부르고 상대적으로 안정적인 부분을 인터페이스라고 부름. 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것임.
59. 객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것임.
60. 응집도는 모듈에 포함된 내부 요소(ex 인스턴스 변수, 메서드)들이 연관돼 있는 정도를 나타내고 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가짐. 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있음. 간단히 말해 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고 모듈의 일부만 변경된다면 응집도가 낮은 것임. 또한 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮은 것임.
61. 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도는 낮다고 말함. 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 됨. `단일책임 원칙`은 클래스는 단 한 가지의 변경 이유만을 가져야 한다는 설계 원칙임.
62. 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도임. 변경의 관점에서 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있음.
63. 캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아짐.
64. getter, setter를 함부로 쓰면 안좋은게 퍼블릭 인터페이스에 인스턴스 변수명이 제대로 노출됨.
65. 객체에게 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드임.
66. 다른 객체에게 접근자 메서드를 통해 값을 변경할 기회를 주지 말고, 본인이 직접 바꿀 수 있도록 해야 캡슐화가 이루어짐. 객체는 단순한 데이터 제공자가 아님.
67. 인터페이스(not Interface, 의존성 객체의 메서드 부분)의 파라미터, 반환값, getter등을 통해서 내부 속성을 유추할 수 있고, 속성값 변경이 메서드의 파라미터 수정을 요구, 메서드 사용부분 전부 수정등으로 파급효과가 발생하므로 캡슐화가 부족하다고 판단됨. 또한 메서드 네임명으로 객체의 속성값이 유추될 수도 있음.
68. 캡슐화란 변할 수 있는 어떤 것이라도 감추는 것임. 그것이 속성의 타입이건, 할인 정책의 종류건 상관없이 내부 구현 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것임.
69. 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 함. 객체가 내부에 어떤 상태를 가지고 그 상태를 관리하는가는 부가적인 문제이고, 중요한 것은 객체가 다른 객체와 협력하는 방식임.
70. 책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 어떤 객체에게 어떤 책임을 할당할지를 결정하기 쉽지 않다는 것임. 책임 할당 과정은 일종의 트레이드 오프 활동이므로 동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라짐. 따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 함.
71. 객체에게 어떤 책임을 할당해야 하는가에 대한 실마리는 협력에서 찾을 수 있음. 객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정됨. 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 함.
72. 협력을 시작하는 주체는 메시지 전송자이기 때문에 협력에 적합한 책임이란 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미함. 다시 말해서 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 하는 것임.
73. 협력에 적합한 책임을 수확하기 위해서는 객체를 결정한 후에 메시지를 선택하는 것이 아니라 메시지를 결정한 후에 객체를 선택해야 함. 메시지가 객체를 선택하게 해야 하는 것임.
74. 메시지기반 설계 관점은 클래스기반의 설계 관점보다 훨씬 유연한 애플리케이션을 만들 수 있게 해줌. 클래스기반의 설계 관점이란 클래스를 결정하고 그 클래스의 책임을 찾아 나서는 것을 말함.
75. 메시지를 먼저 결정하기 때문에 메시지 송신자는 메시지 수신자에 대한 어떠한 가정도 할 수 없음. 메시지 전송자의 관점에서 메시지 수신자가 깔끔하게 캡슐화되는 것임.
76. 올바른 객체지향 설계는 클라이언트가 전송할 메시지를 결정한 후에야 비로소 객체의 상태를 저장하는 데 필요한 내부 데이터에 관해 고민하기 시작함.
77. GRASP 패턴은 책임 할당의 어려움을 해결하기 위한 답을 제시해줌. General Responsibility Assignment Software Pattern의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것임.
78. 설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용함. 도메인 안에는 무수히 많은 개념들이 존재하며 이 도메인 개념들을 책임 할당의 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 좀 더 수월해짐. 따라서 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념임. 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요는 없음. 이 단계에서는 책임을 할당받을 객체들의 종류와 관계에 대한 유용한 정보를 제공할 수 있다면 충분함. 중요한 것은 설계를 시작하는 것이지 도메인 개념들을 완벽하게 정리하는 것이 아님. 도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행해야 함.
79. 메시지는 메시지를 수신할 객체가 아니라 메시지를 전송할 객체의 의도를 반영해서 결정해야 함. 따라서 첫 질문은 다음과 같음. `메시지를 전송할 객체는 무엇을 원하는가?`
80. 두번째 질문은 다음과 같음. `메시지를 수신할 적합한 객체는 누구인가?`
81. 객체의 책임과 책임을 수행하는 데 필요한 상태는 동일한 객체 안에 존재해야 함. 따라서 객체에게 책임을 할당하는 첫번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 할당하는 것임. GRASP에서 이를 `정보전문가 패턴`이라고 부름.
82. 책임을 수행하는 객체가 정보를 알고 있다고 해서 그 정보를 저장하고 있을 필요는 없음. 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있음.
83. 설계 초반부에는 도메인 개념에서 정보전문가에 맞는 객체를 찾는 게 좋음.
84. 메시지를 수신할 객체가 스스로 처리할 수 없는 작업이 있다면 메시지로 도움을 요청해야 하고 메시지는 새로운 객체의 책임으로 할당됨. 이 같은 연쇄적인 메시지 전송과 수신을 통해 협력 공동체가 구성되는 것임.
85. 정보전문가 패턴은 객체에게 책임을 할당할 때 가장 기본이 되는 책임할당 원칙임. 이 패턴을 따르는 것만으로도 자율성이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아짐.
86. 설계는 트레이드오프 활동이기 때문에 동일한 기능을 구현할 수 있는 무수히 많은 설계가 존재함. 따라서 올바른 책임할당을 위해 정보전문가 패턴 이외의 다른 책임할당 패턴들을 함께 고려할 필요가 있음. 책임을 할당할 수 있는 다양한 대안들이 존재한다면 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 게 좋음. GRASP에서는 이를 `낮은 결합도 패턴`과 `높은 응집도 패턴`이라고 부름(ex DiscountCondition이 Movie와 협력하는 게 좋을까, 아니면 Screening과 협력하는 게 좋을까).
87. Movie와 DiscountCondition은 이미 결합되어 있기 때문에 Movie를 DiscountCondition과 협력하게 하면 설계 전체적으로 결합도를 추가하지 않고도 협력을 완성할 수 있음(낮은 결합도 패턴).
88. Screening이 DiscountCondition과 협력해야 한다면 Screening은 기존의 예매를 생성하는 책임에 영화 요금 계산과 관련된 책임 일부를 추가적으로 떠맡게 됨. 본인의 원래 책임외에 추가적인 책임이 생겨서 응집도가 떨어짐(높은 응집도 패턴).
89. 이처럼 책임을 할당하고 코드를 작성하는 매순간마다 낮은 결합도 패턴, 높은 응집도 패턴의 관점에서 전체적인 설계 품질을 검토하면 단순하면서도 재사용 가능하고 유연한 설계를 얻을 수 있을 것임.
90. GRASP의 `창조자 패턴`은 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공함.

```
객체 A를 생성해야 할때, 어떤 객체에게 객체 생성 책임을?
1. B가 A객체를 포함하거나 참조함.
2. B가 A객체를 기록함.
3. B가 A객체를 긴밀하게 사용함.
4. B가 A객체를 초기화하는데 필요한 데이터를 가지고 있음.
```

91. 이처럼 창조자 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것임. 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않음.
92. 협력과 책임이 제대로 동작하는지 확인할 수 있는 유일한 방법은 코드를 작성하고 실행해보는 것 뿐임. 올바르게 설계하고 있는지 궁금하면 코드를 작성해야 함.
93. Screening은 영화를 예매할 책임을 맡으며 그결과로 Reservation 인스턴스를 생성할 책임을 수행해야 함. 다시 말해 Screening은 예매에 대한 정보 전문가인 동시에 Reservation의 창조자임. 책임이 결정됐으므로 메시지를 처리할 수 있는 메서드를 구현하고 동시에 책임을 수행하는 데 필요한 인스턴스 변수를 결정해야 함.
94. 변경에 취약한 클래스란 코드를 수정해야 하는 이유를 하나 이상 가지는 클래스임. 예를 들어 코드 변경의 이유가 순번로직 변경, 기간로직 변경 두가지가 될 수 있음. 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮으며, 이를 해결하기 위해서는 변경의 이유에 따라 클래스를 분리해야 함.
95. 지금 본것처럼, 일반적으로 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋음. 문제는 갓 입문한 개발자들은 클래스 안에서 변경의 이유를 찾는 게 어렵다는 것인데, 변경 이유가 하나 이상인 클래스에 드러나는 패턴을 이해하고 나면 클래스 안에 숨겨진 변경의 이유를 생각보다 쉽게 알아낼 수 있을 것임.

```
1. 인스턴스 변수가 초기화되는 시점을 살펴봐라. 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 채로 냅둠.
2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴봐라. 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮은 것임.
```

96. 클래스를 분리할 때, 다형성을 통해 분리하는 게 좋음. 이때 역할의 개념이 등장하게 됨.
97. 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라는 것이 GRASP의 `다형성 패턴`임. 예를 들어 SequeceCondition, PeriodCondition같이 타입이 나누어지면 다형성 패턴을 적용함.
98. 다형성 패턴은 객체의 타입에 따라 여러 대안들을 수행하는 조건문적인 논리를 사용하지 말라고 경고하며 대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고함.
99. 변경을 캡슐화하도록 책임을 할당하는 것을 GRASP에서 `변경보호 패턴`이라고 함. 다형성 패턴을 쓰면 변경보호 패턴이 자동으로 적용됨. 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당해야 함.
100.  모든 인스턴스 변수는 private로 접근제한자를 설정하는 게 좋을 듯함.
101.  개발자로써 변경에 대비할 수 있는 두가지 방법은 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이고, 다른 하나는 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것임. 상속보다 합성을 사용하는 게 훨씬 변경에 용이함. 합성의 목적은 변경의 용이이며, 변경이 자주 발생하는 곳에 합성을 사용하는 게 좋음.
102.  코드의 구조가 바뀌면 도메인의 구조도 바뀌어야 함. 도메인 모델에 따라 코드의 모습을 정할 수 있으며, 코드의 모습에 따라 모델도 달라져야 함.
103.  여전히 책임을 할당하는 데 어려움을 느끼고 있다면 일단 절차형 코드로 실행되는 프로그램을 빠르게 작성한 후 완성된 코드를 객체지향적인 코드로 변경하는 `리팩토링 기법`을 사용해보는 게 좋음. 이 방법은 실무에서 많은 사람들이 사용하고 있음.
104.  절차형 코드로 작성할 때 발생하는 긴 메서드는 다양한 측면에서 코드의 유지보수에 부정적인 영향을 끼침. 긴 메서드는 응집도가 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어려움. 이러한 메서드를 `몬스터 메서드`라고 부름. 이러한 문제는 이해를 돕기 위해 주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높이는 게 해결책임. 클래스의 응집도와 마찬가지로 메서드의 응집도를 높이는 이유도 변경과 관련이 깊고 작은 메서드들로 조합된 메서드는 마치 주석들을 나열한 것처럼 보이기에 코드를 이해하기도 쉬움.
105.  해당 긴 메서드에서 여러 객체로 책임을 분배할 때 가장 먼저 할일은 메서드를 응집도 있는 수준으로 분해하는 것이고, 이렇게 분리하면 각 메서드를 적절한 클래스로 이동하기에 더 수월해짐.
106.  메서드를 이동할 때, 각 메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동시키면 됨. 어떤 데이터를 사용하는지를 가장 쉽게 알 수 있는 방법은 메서드 안에서 어떤 클래스의 접근자 메서드를 사용하는지 파악하는 것임.
107.  책임주도 설계방법에 익숙하지 않다면 일단 데이터 중심으로 구현한 후 이를 리팩토링하더라도 유사한 결과를 얻을 수 있음. 처음부터 책임주도 설계방법을 따르는 것보다 동작하는 코드를 작성한 후에 리팩토링하는 것은 더 훌륭한 결과물을 낳을 수도 있음.
108.  객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것임. 훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 함. 좀 더 정확하게 말해서 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 함. 여기서 중요한 것은 책임이 객체가 수신할 수 있는 메시지의 기반이 된다는 것임.
109.  애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 알아야 함.
110.  객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성함. 훌륭한 퍼블릭 인터페이스를 얻기 위해서는 책임주도 설계방법을 따르는 것만으로는 부족함. 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 익히고 적용해야 함.
111.  퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법이 있음.

```
1. 디미터 법칙
2. 묻지 말고 시켜라
3. 의도를 드러내는 인터페이스
4. 명령-쿼리 분리
```

112.

### 개념

1. 글래스는 이론과 실무의 우선순위에서 이론보다 실무가 먼저라고 함. 소프트웨어 설계와 유지보수에 중점을 두려면 이론이 아닌 실무에 초점을 맞추는 것이 효과적임.
2. 추상적인 개념과 이론은 훌륭한 코드를 작성하는 데 필요한 도구일 뿐임.
3. 로버트 마틴이 '클린 소프트웨어'에서 언급한 소프트웨어 모듈이 가져야 하는 세 가지 기능으로 제대로 실행되어야 함, 변경이 용이해야 함, 이해하기 쉬워야 함 을 들었음.
4. 티켓판매소 예시의 문제점은 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점에서 우리의 상식과 다르게 동작하므로 이해가 잘 안되고, 소극장이 관람객과 판매원에 직접 접근한다는 점에서 강한 결합도를 가지게 되어 변경이 어려워진다는 점임.
5. 위의 변경이 어려워지는 부분에서 의존성이 관련된 문제이고, 과한 의존성은 결합도를 높히게 됨. 하지만 이러한 의존성을 완전히 없애는 것이 정답이 아니라, 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것을 목표로 두어야 함.
6. 티켓판매소 예시에서의 노이해, 변경불용이 문제를 해결하는 방법은 간단하게도, 소극장이 관람객과 판매원에 관해 세세한 부분까지 알지 못하도록 정보를 차단하는 것임. 또한 관람객과 판매원이 스스로 일을 할 수 있는 자율성을 부여하면 됨.
7. 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 함. 캡슐화를 통해 객체 내부로의 접근을 제한하면, 객체 사이의 결합도를 낮출 수 있으므로 설계 변경이 좀 더 용이해짐.
8. 특정 클래스를 캡슐화 하기 위해서는 다른 클래스가 해당 클래스에 직접 접근하는 부분을 전부 해당 클래스가 내부적으로 수행하도록 변경함.
9. 객체의 자율성을 높이는 방향으로 설계를 개선하면, 이해하기 쉽고 유연한 설계를 얻을 수 있음.
10. 프로세스(메서드), 데이터(인스턴스 변수)를 별도의 모듈에 위치시키는 방식을 `절차적 프로그래밍`이라고 부름.
11. 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 `객체지향 프로그래밍`이라고 부름.
12. 현실에서는 수동적인 존재라고 하더라도, 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀜. 이를 의인화라고 부름.
13. 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 `도메인`이라고 부름.
14. 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있음.
15. 클래스의 구조는 도메인의 구조와 유사한 형태를 띄어야 함.
16. 설계된 도메인을 바탕으로 클래스 구조를 작성해야 하고, 클래스 명은 도메인 개념의 이름과 유사하게 지어야 함.
17. 객체가 자율적인 존재로 우뚝서기 위해서는 외부의 간섭을 최소화해야 함.
18. 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이고, 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라고 부름.
19. 메시지 수신 객체가 메시지를 처리하는 방법(메서드)을 자율적으로 결정함.
20. 유사한 클래스를 관리하기 위해 상속, 특히 추상클래스와 인터페이스를 사용함.
21. 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 `Template Method`라고 함.
22. 인터페이스의 공유만 필요한 경우 interface를 사용하고, 구현의 공유가 추가적으로 필요한 경우 abstract class를 사용함.
23. 대부분의 사람들은 상속의 목적이 메서드나 인스턴스 변수를 재사용 하는 것이라고 생각하지만, 상속을 통해 부모 클래스의 인터페이스를 물려받아 부모 클래스 대신 사용될 수 있다는 점이 더 중요함.
24. 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 `구현 상속`이라고 하며, 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 `인터페이스 상속` 이라고 함. 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 함.
25. 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 함.
26. 코드 상에서와 달리 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라짐. 이를 `다형성`이라고 함.
27. 다형성은 객체지향 프로그램의 컴파일타임 의존성과 런타임의존성이 다를 수 있다는 사실에 기반으로 함. 객체지향은 동적 바인딩을 사용하므로, 다형성의 활용이 가능한 것임.
28. 메시지와 메서드를 실행 시점에 바인딩 하는 것을 `동적 바인딩`이라고 하고, 컴파일 시점에 바인딩 하는 것을 `정적 바인딩`이라고 함.
29. 추상화를 사용할 경우 두가지 장점을 누릴 수 있음.

```
1. 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있음.
2. 추상화를 이용하면 설계가 좀 더 유연해짐.
```

30. 추상화의 첫번째 장점을 통해, 추상화를 사용해 애플리케이션의 협력흐름을 상위정책으로 기술할 수 있으며, 간략한 기술 덕에 새로운 기능을 쉽게 추가할 수 있음.
31. 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라 함. 객체가 협력에 참여하기 위해 수행하는 로직을 책임이라고 함. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할(추상화)을 구성함.
32. 메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단임.
33. 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상시킬 수 있음. 자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청함. 메시지 수신 객체 역시 메시지를 처리하던 중에 직접 처리할 수 없는 정보나 행동이 필요한 경우 또 다른 객체에게 도움을 요청함. 이처럼 객체들 사이의 협력을 구성하는 `일련의 요청과 응답의 흐름`을 통해 애플리케이션의 기능이 구현됨.
34. 객체지향 설계에서는 상태를 분할의 중심축으로 삼는 방법, 책임을 분할의 중심축으로 삼는 방법 두 가지가 있음. 데이터 중심의 관점은 객체의 상태에 초점을 맞추고, 책임 중심의 관점은 객체의 행동에 초점을 맞춤. 훌륭한 객체지향 설계는 데이터가 아닌 책임에 초점을 맞춰야 함. 객체의 상태는 구현에 속하고 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너짐. 그에 비해, 객체의 책임을 중심축으로 삼으면, 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써, 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지할 수 있음.
35. 책임중심 설계는 `책임이 무엇인가`를 묻는 것으로 시작한다면 데이터중심 설계는 객체가 내부에 저장해야 하는 `데이터가 무엇인가`를 묻는 것으로 시작함. 책임을 명확히하고 분리하는 작업을 안했으니 관련있을 법한 데이터를 다 때려박는 수밖에 없음. 또한 객체가 무엇을 할 것인가 결정하기 전에 객체가 가져야 할 데이터를 설계함.
36. 데이터중심 설계가 가진 대표적인 문제점은 캡슐화 위반, 높은 결합도, 낮은 응집도임.
37. 데이터에 초점을 맞추게 되면 getter,setter처럼 오퍼레이션 명에 데이터 이름이 들어가게 됨. 또한 `누가 이 객체의 ~를 사용할거야`처럼 협력에 관해 고민하지 않아 협력을 파악하지 못하니 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있도록 최대한 많은 무분별한 접근자 메서드가 추가됨.
38. 이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 `추측에 의한 설계 전략`이라고 부름. 따라서 프로그래머는 내부 상태를 드러내는 메서드를 최대한 많이 추가해야 한다는 압박에 시달릴 수 밖에 없으며 결과적으로 대부분의 내부 구현이 퍼블릭 인터페이스에 그대로 노출될 수 밖에 없음. 그 결과, 캡슐화의 원칙을 위반하는 변경에 취약한 설계를 얻게 됨.
39. 이처럼 데이터중심 설계는 객체의 캡슐화를 약화시키기 때문에 클라이언트가 객체의 구현에 강하게 결합됨. 결합도 측면에서 데이터 중심 설계가 가지는 또 다른 단점은 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합될 수 밖에 없음.
40. 데이터중심 설계가 변경에 취약한 이유는 두가지임.

```
1. 데이터중심 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요함.
2. 데이터중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정함.
```

41. 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성됨. 하나는 객체가 수신하는 메시지의 집합이고 다른 하나는 외부의 객체에게 전송하는 메시지의 집합임. 대부분의 사람들은 객체가 수신하는 메시지에 초점을 맞추지만 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직함.
42. 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 함.
43. 메시지는 오퍼레이션명과 인자로 구성되며, 메시지 전송은 여기에 메시지 수신자를 추가한 것임. 또한 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려있음.
44. 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 함. 또한 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부름. 실제 실행되는 코드인 메서드와는 별개임.
45. 오퍼레이션과 파라미터 목록을 합쳐서 시그니처라고 부름.
46.

### 코딩

1. 일반배열을 ArrayList같은 List에 추가하기 위해서는 Arrays.asList()를 통해 List로 변경해준 뒤, addAll()을 사용해야 함.
2. List의 remove()는 제거와 동시에 값을 반환해줌.
